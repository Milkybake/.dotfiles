SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/autoloclist.vim
Sourced 2 times
Total time:   0.000056
 Self time:   0.000056

count  total (s)   self (s)
    2              0.000012 if exists('g:loaded_syntastic_notifier_autoloclist') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
    1              0.000001 endif
    1              0.000002 let g:loaded_syntastic_notifier_autoloclist = 1
                            
    1              0.000001 let g:SyntasticAutoloclistNotifier = {}
                            
                            " Public methods {{{1
                            "
    1              0.000003 function! g:SyntasticAutoloclistNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticAutoloclistNotifier.refresh(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
                                call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticAutoloclistNotifier.AutoToggle(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
                                let auto_loc_list = syntastic#util#var('auto_loc_list')
                                if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
                                else
                                    if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
                                        try
                                            " Vim 7.4.2200 or later
                                            let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
                                        endtry
                            
                                        if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
                                            call SyntasticLoclistHide()
                            
                                            try
                                                " Vim 7.4.2200 or later
                                                call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
                                            endtry
                                            let w:syntastic_loclist_set = []
                                        endif
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/balloons.vim
Sourced 2 times
Total time:   0.000051
 Self time:   0.000051

count  total (s)   self (s)
    2              0.000008 if exists('g:loaded_syntastic_notifier_balloons') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
    1              0.000001 endif
    1              0.000002 let g:loaded_syntastic_notifier_balloons = 1
                            
    1              0.000002 if !has('balloon_eval')
                                let g:syntastic_enable_balloons = 0
    1              0.000001 endif
                            
    1              0.000002 let g:SyntasticBalloonsNotifier = {}
                            
                            " Public methods {{{1
                            
    1              0.000001 function! g:SyntasticBalloonsNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticBalloonsNotifier.enabled() abort " {{{2
                                return has('balloon_eval') && syntastic#util#var('enable_balloons')
                            endfunction " }}}2
                            
                            " Update the error balloons
    1              0.000001 function! g:SyntasticBalloonsNotifier.refresh(loclist) abort " {{{2
                                unlet! b:syntastic_private_balloons
                                if self.enabled() && !a:loclist.isEmpty()
                                    let b:syntastic_private_balloons = a:loclist.balloons()
                                    if !empty(b:syntastic_private_balloons)
                                        set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " Reset the error balloons
                            " @vimlint(EVL103, 1, a:loclist)
    1              0.000001 function! g:SyntasticBalloonsNotifier.reset(loclist) abort " {{{2
                                if has('balloon_eval') && !empty(get(b:, 'syntastic_private_balloons', {}))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    set noballooneval
                                endif
                                unlet! b:syntastic_private_balloons
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:loclist)
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000001 function! SyntasticBalloonsExprNotifier() abort " {{{2
                                if !exists('b:syntastic_private_balloons')
                                    return ''
                                endif
                                return get(b:syntastic_private_balloons, v:beval_lnum, '')
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim
Sourced 2 times
Total time:   0.000160
 Self time:   0.000160

count  total (s)   self (s)
    2              0.000008 if exists('g:loaded_syntastic_checker') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
    1              0.000000 endif
    1              0.000002 let g:loaded_syntastic_checker = 1
                            
    1              0.000002 let g:SyntasticChecker = {}
                            
                            " Public methods {{{1
                            
    1              0.000001 function! g:SyntasticChecker.New(args, ...) abort " {{{2
                                let newObj = copy(self)
                            
                                let newObj._filetype = a:args['filetype']
                                let newObj._name = a:args['name']
                            
                                if a:0
                                    " redirected checker
                                    let newObj._exec_default = get(a:args, 'exec', a:1['_exec_default'])
                            
                                    let filetype = a:1['_filetype']
                                    let name = a:1['_name']
                                    let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
                                    if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
                                        let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
                                    endif
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
                                else
                                    let newObj._exec_default = get(a:args, 'exec', newObj._name)
                                    if newObj._exec_default ==# ''
                                        let newObj._exec_default = '<dummy>'
                                    endif
                                    let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    endif
                                endif
                            
                                let newObj._locListFunc = function(prefix . 'GetLocList')
                            
                                if exists('*' . prefix . 'IsAvailable')
                                    let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
                                else
                                    let newObj._isAvailableFunc = function('s:_isAvailableDefault')
                                endif
                            
                                if exists('*' . prefix . 'GetHighlightRegex')
                                    let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
                                endif
                            
                                return newObj
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.getFiletype() abort " {{{2
                                return self._filetype
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getName() abort " {{{2
                                return self._name
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getCName() abort " {{{2
                                return self._filetype . '/' . self._name
                            endfunction " }}}2
                            
                            " Synchronise _exec with user's setting.  Force re-validation if needed.
                            "
                            " XXX: This function must be called at least once before calling either
                            " getExec() or getExecEscaped().  Normally isAvailable() does that for you
                            " automatically, but you should keep still this in mind if you change the
                            " current checker workflow.
    1              0.000001 function! g:SyntasticChecker.syncExec(...) abort " {{{2
                                if a:0
                                    let self._exec = a:1
                                else
                                    let suffix = self._name . '_exec'
                                    let self._exec = expand(
                                        \ syntastic#util#var(self._filetype . '_' . suffix,
                                        \ syntastic#util#var(suffix, self._exec_default)), 1 )
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getExec() abort " {{{2
                                return self._exec
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getExecEscaped() abort " {{{2
                                return syntastic#util#shescape(self._exec)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getLocListRaw() abort " {{{2
                                let checker_start = reltime()
                                let name = self.getCName()
                            
                                if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) .
                                            \ ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' .
                                            \ 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
                                endif
                            
                                try
                                    let list = self._locListFunc()
                                    if self._exec !=# ''
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
                                    endif
                                catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
                                endtry
                                call self._populateHighlightRegexes(list)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
                                call self._quietMessages(list)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE,
                                    \ 'getLocList: checker ' . name . ' run in ' . split(reltimestr(reltime(checker_start)))[0] . 's')
                                return list
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker.getLocList() abort " {{{2
                                return g:SyntasticLoclist.New(self.getLocListRaw())
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.getVersion(...) abort " {{{2
                                if !exists('self._version')
                                    let command = a:0 ? a:1 : self.getExecEscaped() . ' --version'
                                    let version_output = syntastic#util#system(command)
                                    call self.log('getVersion: ' . string(command) . ': ' .
                                        \ string(split(version_output, "\n", 1)) .
                                        \ (v:shell_error ? ' (exit code ' . v:shell_error . ')' : '') )
                                    let parsed_ver = syntastic#util#parseVersion(version_output)
                                    if len(parsed_ver)
                                        call self.setVersion(parsed_ver)
                                    else
                                        call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', split(version_output, "\n", 1))
                                        call syntastic#log#error("checker " . self.getCName() . ": can't parse version string (abnormal termination?)")
                                    endif
                                endif
                                return get(self, '_version', [])
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.setVersion(version) abort " {{{2
                                if len(a:version)
                                    let self._version = copy(a:version)
                                    call self.log(self.getExec() . ' version =', a:version)
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.log(msg, ...) abort " {{{2
                                let leader = self.getCName() . ': '
                                if a:0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg, a:1)
                                else
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg)
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.makeprgBuild(opts) abort " {{{2
                                let basename = self._filetype . '_' . self._name . '_'
                            
                                let parts = []
                                call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
                                call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
                                call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
                                call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
                                call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
                                return join(parts)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.isAvailable() abort " {{{2
                                call self.syncExec()
                            
                                if !has_key(self, '_available')
                                    let self._available = {}
                                endif
                                if !has_key(self._available, self._exec)
                                    let self._available[self._exec] = self._isAvailableFunc()
                                endif
                            
                                return self._available[self._exec]
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.isDisabled() abort " {{{2
                                return has_key(self, '_enable') && syntastic#util#var(self._enable, -1) <= 0
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker.wantSort() abort " {{{2
                                return syntastic#util#var(self._filetype . '_' . self._name . '_sort', 0)
                            endfunction " }}}2
                            
                            " This method is no longer used by syntastic.  It's here only to maintain
                            " backwards compatibility with external checkers which might depend on it.
    1              0.000002 function! g:SyntasticChecker.setWantSort(val) abort " {{{2
                                if !exists('g:syntastic_' . self._filetype . '_' . self._name . '_sort')
                                    let g:syntastic_{self._filetype}_{self._name}_sort = a:val
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000001 function! g:SyntasticChecker._quietMessages(errors) abort " {{{2
                                " wildcard quiet_messages
                                let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
                                if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
                                let name = self._filetype . '_' . self._name
                                try
                                    call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
                                catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
                                if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticChecker._populateHighlightRegexes(errors) abort " {{{2
                                if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticChecker._getOpt(opts, basename, name, default) abort " {{{2
                                let ret = []
                                call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
                                call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
                                call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
                                return ret
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000002 function! s:_isAvailableDefault() dict " {{{2
                                return executable(self.getExec())
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/cursor.vim
Sourced 2 times
Total time:   0.000082
 Self time:   0.000082

count  total (s)   self (s)
    2              0.000009 if exists('g:loaded_syntastic_notifier_cursor') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
    1              0.000001 endif
    1              0.000001 let g:loaded_syntastic_notifier_cursor = 1
                            
    1              0.000001 let g:SyntasticCursorNotifier = {}
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticCursorNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticCursorNotifier.enabled() abort " {{{2
                                return syntastic#util#var('echo_current_error')
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticCursorNotifier.refresh(loclist) abort " {{{2
                                if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif
                            endfunction " }}}2
                            
                            " @vimlint(EVL103, 1, a:loclist)
    1              0.000001 function! g:SyntasticCursorNotifier.reset(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
                                autocmd! syntastic CursorMoved
                                unlet! b:syntastic_private_messages
                                let b:syntastic_private_line = -1
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:loclist)
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000001 function! SyntasticRefreshCursor() abort " {{{2
                                if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
                                    return
                                endif
                            
                                if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
                                let l = line('.')
                                let current_messages = get(b:syntastic_private_messages, l, {})
                            
                                if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
                                if b:syntastic_cursor_columns
                                    let c = virtcol('.')
                                    if !exists('b:syntastic_private_idx')
                                        let b:syntastic_private_idx = -1
                                    endif
                            
                                    if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
                                        return
                                    else
                                        let b:syntastic_private_line = l
                                    endif
                            
                                    if !empty(current_messages)
                                        let b:syntastic_private_idx = s:_find_index(c, current_messages)
                                        call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
                                    else
                                        let b:syntastic_private_idx = -1
                                        echo
                                    endif
                                else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000003 function! s:_is_same_index(line, old_line, column, idx, messages) abort " {{{2
                                if a:old_line >= 0 && a:line == a:old_line && a:idx >= 0
                                    if len(a:messages) <= 1
                                        return 1
                                    endif
                            
                                    if a:messages[a:idx].scol <= a:column || a:idx == 0
                                        if a:idx == len(a:messages) - 1 || a:column < a:messages[a:idx + 1].scol
                                            return 1
                                        else
                                            return 0
                                        endif
                                    else
                                        return 0
                                    endif
                                else
                                    return 0
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! s:_find_index(column, messages) abort " {{{2
                                let max = len(a:messages) - 1
                                if max == 0
                                    return 0
                                endif
                                let min = 0
                            
                                " modified binary search: assign index 0 to columns to the left of the first error
                                while min < max - 1
                                    let mid = (min + max) / 2
                                    if a:column < a:messages[mid].scol
                                        let max = mid
                                    else
                                        let min = mid
                                    endif
                                endwhile
                            
                                return a:column < a:messages[max].scol ? min : max
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim
Sourced 2 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    2              0.000009 if exists('g:loaded_syntastic_notifier_highlighting') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
    1              0.000001 endif
    1              0.000002 let g:loaded_syntastic_notifier_highlighting = 1
                            
                            " Highlighting requires getmatches introduced in 7.1.040
    1              0.000005 let s:has_highlighting = v:version > 701 || (v:version == 701 && has('patch040'))
    1              0.000001 lockvar s:has_highlighting
                            
    1              0.000001 let g:SyntasticHighlightingNotifier = {}
                            
    1              0.000001 let s:setup_done = 0
                            
                            " Public methods {{{1
                            
    1              0.000001 function! g:SyntasticHighlightingNotifier.New() abort " {{{2
                                let newObj = copy(self)
                            
                                if !s:setup_done
                                    call self._setup()
                                    let s:setup_done = 1
                                    lockvar s:setup_done
                                endif
                            
                                return newObj
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticHighlightingNotifier.enabled() abort " {{{2
                                return s:has_highlighting && syntastic#util#var('enable_highlighting')
                            endfunction " }}}2
                            
                            " Sets error highlights in the current window
    1              0.000001 function! g:SyntasticHighlightingNotifier.refresh(loclist) abort " {{{2
                                if self.enabled()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
                                    call self._reset()
                                    let buf = bufnr('')
                                    let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
                                    for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " Remove all error highlights from the window
                            " @vimlint(EVL103, 1, a:loclist)
    1              0.000001 function! g:SyntasticHighlightingNotifier.reset(loclist) abort " {{{2
                                if s:has_highlighting
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
                                    call self._reset()
                                endif
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:loclist)
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
                            " One time setup: define our own highlighting
    1              0.000001 function! g:SyntasticHighlightingNotifier._setup() abort " {{{2
                                if s:has_highlighting
                                    if !hlexists('SyntasticError')
                                        highlight link SyntasticError SpellBad
                                    endif
                                    if !hlexists('SyntasticWarning')
                                        highlight link SyntasticWarning SpellCap
                                    endif
                                    if !hlexists('SyntasticStyleError')
                                        highlight link SyntasticStyleError SyntasticError
                                    endif
                                    if !hlexists('SyntasticStyleWarning')
                                        highlight link SyntasticStyleWarning SyntasticWarning
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticHighlightingNotifier._reset() abort " {{{2
                                for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
                                endfor
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim
Sourced 2 times
Total time:   0.000239
 Self time:   0.000239

count  total (s)   self (s)
    2              0.000008 if exists('g:loaded_syntastic_loclist') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
    1              0.000001 endif
    1              0.000001 let g:loaded_syntastic_loclist = 1
                            
    1              0.000001 let g:SyntasticLoclist = {}
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticLoclist.New(rawLoclist) abort " {{{2
                                let newObj = copy(self)
                            
                                let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
                                for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
                                let newObj._rawLoclist = llist
                                let newObj._name = ''
                                let newObj._owner = bufnr('')
                                let newObj._sorted = 0
                                let newObj._columns = g:syntastic_cursor_columns
                            
                                return newObj
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.current(...) abort " {{{2
                                let buf = a:0 ? a:1 : bufnr('')
                                let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
                                if type(loclist) != type({}) || empty(loclist)
                                    unlet! loclist
                                    let loclist = g:SyntasticLoclist.New([])
                                endif
                                return loclist
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.extend(other) abort " {{{2
                                call extend(self._rawLoclist, a:other.copyRaw())
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.sort() abort " {{{2
                                if !self._sorted
                                    for e in self._rawLoclist
                                        call s:_set_screen_column(e)
                                    endfor
                            
                                    call sort(self._rawLoclist, self._columns ? 's:_compare_error_items_by_columns' : 's:_compare_error_items_by_lines')
                            
                                    let self._sorted = 1
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.isEmpty() abort " {{{2
                                return empty(self._rawLoclist)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.isNewerThan(stamp) abort " {{{2
                                if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
                                endif
                                return syntastic#util#compareLexi(self._stamp, a:stamp) > 0
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.copyRaw() abort " {{{2
                                return copy(self._rawLoclist)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getRaw() abort " {{{2
                                return self._rawLoclist
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getBuffers() abort " {{{2
                                return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getCursorColumns() abort " {{{2
                                return self._columns
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getStatuslineFlag() abort " {{{2
                                if !exists('self._stl_format')
                                    let self._stl_format = ''
                                endif
                                if !exists('self._stl_flag')
                                    let self._stl_flag = ''
                                endif
                            
                                if g:syntastic_stl_format !=# self._stl_format
                                    let self._stl_format = g:syntastic_stl_format
                            
                                    if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = {
                                            \ '%':  '%',
                                            \ 't':  num_issues,
                                            \ 'e':  num_errors,
                                            \ 'w':  num_warnings,
                                            \ 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''),
                                            \ 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''),
                                            \ 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''),
                                            \ 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''),
                                            \ 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''),
                                            \ 'fe': (num_errors ? errors[0]['lnum'] : ''),
                                            \ 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''),
                                            \ 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''),
                                            \ 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
                                        let self._stl_flag = ''
                                    endif
                                endif
                            
                                return self._stl_flag
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getFirstError(...) abort " {{{2
                                let max_issues = len(self._rawLoclist)
                                if a:0 && a:1 < max_issues
                                    let max_issues = a:1
                                endif
                            
                                for idx in range(max_issues)
                                    if get(self._rawLoclist[idx], 'type', '') ==? 'E'
                                        return idx + 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getName() abort " {{{2
                                return len(self._name)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.setName(name) abort " {{{2
                                let self._name = a:name
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.getOwner() abort " {{{2
                                return self._owner
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticLoclist.setOwner(buffer) abort " {{{2
                                let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.deploy() abort " {{{2
                                let self._stamp = syntastic#util#stamp()
                                for buf in self.getBuffers()
                                    call setbufvar(buf, 'syntastic_loclist', self)
                                endfor
                            endfunction " }}}2
                            
    1              0.000000 function! g:SyntasticLoclist.destroy() abort " {{{2
                                for buf in self.getBuffers()
                                    call setbufvar(buf, 'syntastic_loclist', {})
                                endfor
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.decorate(tag) abort " {{{2
                                for e in self._rawLoclist
                                    let e['text'] .= ' [' . a:tag . ']'
                                endfor
                            endfunction " }}}2
                            
    1              0.000000 function! g:SyntasticLoclist.balloons() abort " {{{2
                                if !exists('self._cachedBalloons')
                                    let sep = has('balloon_multiline') ? "\n" : ' | '
                            
                                    let self._cachedBalloons = {}
                                    for e in self._rawLoclist
                                        let buf = e['bufnr']
                            
                                        if !has_key(self._cachedBalloons, buf)
                                            let self._cachedBalloons[buf] = {}
                                        endif
                            
                                        if has_key(self._cachedBalloons[buf], e['lnum'])
                                            let self._cachedBalloons[buf][e['lnum']] .= sep . e['text']
                                        else
                                            let self._cachedBalloons[buf][e['lnum']] = e['text']
                                        endif
                                    endfor
                                endif
                            
                                return get(self._cachedBalloons, bufnr(''), {})
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.errors() abort " {{{2
                                if !exists('self._cachedErrors')
                                    let self._cachedErrors = self.filter({'type': 'E'})
                                endif
                                return self._cachedErrors
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.warnings() abort " {{{2
                                if !exists('self._cachedWarnings')
                                    let self._cachedWarnings = self.filter({'type': 'W'})
                                endif
                                return self._cachedWarnings
                            endfunction " }}}2
                            
                            " Legacy function.  Syntastic no longer calls it, but we keep it
                            " around because other plugins (f.i. powerline) depend on it.
    1              0.000001 function! g:SyntasticLoclist.hasErrorsOrWarningsToDisplay() abort " {{{2
                                return !self.isEmpty()
                            endfunction " }}}2
                            
                            " cache used by EchoCurrentError()
    1              0.000001 function! g:SyntasticLoclist.messages(buf) abort " {{{2
                                if !exists('self._cachedMessages')
                                    let self._cachedMessages = {}
                            
                                    let errors = self.errors() + self.warnings()
                                    for e in errors
                                        let b = e['bufnr']
                                        let l = e['lnum']
                            
                                        if !has_key(self._cachedMessages, b)
                                            let self._cachedMessages[b] = {}
                                        endif
                            
                                        if !has_key(self._cachedMessages[b], l)
                                            let self._cachedMessages[b][l] = [e]
                                        elseif self._columns
                                            call add(self._cachedMessages[b][l], e)
                                        endif
                                    endfor
                            
                                    if self._columns
                                        if !self._sorted
                                            for b in keys(self._cachedMessages)
                                                for l in keys(self._cachedMessages[b])
                                                    if len(self._cachedMessages[b][l]) > 1
                                                        for e in self._cachedMessages[b][l]
                                                            call s:_set_screen_column(e)
                                                        endfor
                                                        call sort(self._cachedMessages[b][l], 's:_compare_error_items_by_columns')
                                                    endif
                                                endfor
                                            endfor
                                        endif
                            
                                        for b in keys(self._cachedMessages)
                                            for l in keys(self._cachedMessages[b])
                                                call s:_remove_shadowed_items(self._cachedMessages[b][l])
                                            endfor
                                        endfor
                                    endif
                                endif
                            
                                return get(self._cachedMessages, a:buf, {})
                            endfunction " }}}2
                            
                            "Filter the list and return new native loclist
                            "e.g.
                            "  .filter({'bufnr': 10, 'type': 'e'})
                            "
                            "would return all errors for buffer 10.
                            "
                            "Note that all string comparisons are done with ==?
    1              0.000001 function! g:SyntasticLoclist.filter(filters) abort " {{{2
                                let conditions = values(map(copy(a:filters), 's:_translate(v:key, v:val)'))
                                let filter = len(conditions) == 1 ?
                                    \ conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
                                return filter(copy(self._rawLoclist), filter)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticLoclist.setloclist(new) abort " {{{2
                                if !exists('w:syntastic_loclist_set')
                                    let w:syntastic_loclist_set = []
                                endif
                                if a:new || empty(w:syntastic_loclist_set) || w:syntastic_loclist_set != [self._owner, getbufvar(self._owner, 'changedtick')]
                                    let replace = !a:new && g:syntastic_reuse_loc_lists && !empty(w:syntastic_loclist_set)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
                                    call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
                                    try
                                        " Vim 7.4.2200 or later
                                        call setloclist(0, [], 'r', { 'title': ':SyntasticCheck ' . self._name })
                                    catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                        " do nothing
                                    endtry
                                    call syntastic#util#setLastTick(self._owner)
                                    let w:syntastic_loclist_set = [self._owner, getbufvar(self._owner, 'syntastic_lasttick')]
                                endif
                            endfunction " }}}2
                            
                            "display the cached errors for this buf in the location list
    1              0.000001 function! g:SyntasticLoclist.show() abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: show')
                                call self.setloclist(0)
                            
                                if !&previewwindow && !self.isEmpty()
                                    let num = winnr()
                                    execute 'lopen ' . syntastic#util#var('loc_list_height')
                                    if num != winnr()
                                        execute num . 'wincmd w'
                                    endif
                            
                                    " try to find the loclist window and set w:quickfix_title
                                    let errors = getloclist(0)
                                    for buf in tabpagebuflist()
                                        if buflisted(buf) && bufloaded(buf) && getbufvar(buf, '&buftype') ==# 'quickfix'
                                            let win = bufwinnr(buf)
                                            let title = getwinvar(win, 'quickfix_title')
                            
                                            " TODO: try to make sure we actually own this window; sadly,
                                            " errors == getloclist(0) is the only somewhat safe way to
                                            " achieve that
                                            if strpart(title, 0, 16) ==# ':SyntasticCheck ' ||
                                                        \ ( (title ==# '' || title ==# ':setloclist()') && errors == getloclist(0) )
                                                call setwinvar(win, 'quickfix_title', ':SyntasticCheck ' . self._name)
                                                call setbufvar(buf, 'syntastic_owner_buffer', self._owner)
                                            endif
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Public functions {{{1
                            
    1              0.000001 function! SyntasticLoclistHide() abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
                                silent! lclose
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000002 function! s:_translate(key, val) abort " {{{2
                                return 'get(v:val, ' . string(a:key) . ', "") ==? ' . string(a:val)
                            endfunction " }}}2
                            
    1              0.000001 function! s:_set_screen_column(item) abort " {{{2
                                if !has_key(a:item, 'scol')
                                    let col = get(a:item, 'col', 0)
                                    if col != 0 && get(a:item, 'vcol', 0) == 0
                                        let buf = str2nr(a:item['bufnr'])
                                        try
                                            let line = getbufline(buf, a:item['lnum'])[0]
                                        catch  /\m^Vim\%((\a\+)\)\=:E684/
                                            let line = ''
                                        endtry
                                        let a:item['scol'] = syntastic#util#screenWidth(strpart(line, 0, col), getbufvar(buf, '&tabstop'))
                                    else
                                        let a:item['scol'] = col
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! s:_remove_shadowed_items(errors) abort " {{{2
                                " keep only the first message at a given column
                                let i = 0
                                while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].scol == a:errors[i].scol
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile
                            
                                " merge messages with the same text
                                let i = 0
                                while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].text == a:errors[i].text
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile
                            endfunction " }}}2
                            
    1              0.000002 function! s:_compare_error_items_by_columns(a, b) abort " {{{2
                                if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['scol'] != a:b['scol']
                                    " sort by screen column
                                    return a:a['scol'] - a:b['scol']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    return 0
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! s:_compare_error_items_by_lines(a, b) abort " {{{2
                                if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    " sort by screen column
                                    return a:a['scol'] - a:b['scol']
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim
Sourced 2 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    2              0.000009 if exists('g:loaded_syntastic_modemap') || !exists('g:loaded_syntastic_plugin')
    1              0.000000     finish
    1              0.000000 endif
    1              0.000002 let g:loaded_syntastic_modemap = 1
                            
    1              0.000002 let g:SyntasticModeMap = {}
                            
                            " Public methods {{{1
                            
    1              0.000001 function! g:SyntasticModeMap.Instance() abort " {{{2
                                if !exists('s:SyntasticModeMapInstance')
                                    let s:SyntasticModeMapInstance = copy(self)
                                    call s:SyntasticModeMapInstance.synch()
                                endif
                            
                                return s:SyntasticModeMapInstance
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticModeMap.synch() abort " {{{2
                                if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
                                    let self._mode = 'active'
                                    let self._activeFiletypes = []
                                    let self._passiveFiletypes = []
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.allowsAutoChecking(filetype) abort " {{{2
                                let registry = g:SyntasticRegistry.Instance()
                                let fts = registry.resolveFiletypes(a:filetype)
                            
                                if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
                                    return self._noFiletypesArePassive(fts)
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.doAutoChecking(buf) abort " {{{2
                                let local_mode = getbufvar(a:buf, 'syntastic_mode')
                                if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
                                endif
                            
                                return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticModeMap.isPassive() abort " {{{2
                                return self._mode ==# 'passive'
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticModeMap.toggleMode() abort " {{{2
                                call self.synch()
                            
                                if self._mode ==# 'active'
                                    let self._mode = 'passive'
                                else
                                    let self._mode = 'active'
                                endif
                            
                                "XXX Changing a global variable.  Tsk, tsk...
                                if !exists('g:syntastic_mode_map')
                                    let g:syntastic_mode_map = {}
                                endif
                                let g:syntastic_mode_map['mode'] = self._mode
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticModeMap.echoMode() abort " {{{2
                                echo 'Syntastic: ' . self._mode . ' mode enabled'
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticModeMap.modeInfo(filetypes) abort " {{{2
                                echomsg 'Syntastic version: ' . g:syntastic_version
                                let type = len(a:filetypes) ? a:filetypes[0] : &filetype
                                echomsg 'Info for filetype: ' . type
                            
                                call self.synch()
                                echomsg 'Global mode: ' . self._mode
                                if self._mode ==# 'active'
                                    if len(self._passiveFiletypes)
                                        let plural = len(self._passiveFiletypes) != 1 ? 's' : ''
                                        echomsg 'Passive filetype' . plural . ': ' . join(sort(copy(self._passiveFiletypes)))
                                    endif
                                else
                                    if len(self._activeFiletypes)
                                        let plural = len(self._activeFiletypes) != 1 ? 's' : ''
                                        echomsg 'Active filetype' . plural . ': ' . join(sort(copy(self._activeFiletypes)))
                                    endif
                                endif
                                echomsg 'Filetype ' . type . ' is ' . (self.allowsAutoChecking(type) ? 'active' : 'passive')
                            
                                if !len(a:filetypes)
                                    if exists('b:syntastic_mode') && (b:syntastic_mode ==# 'active' || b:syntastic_mode ==# 'passive')
                                        echomsg 'Local mode: ' . b:syntastic_mode
                                    endif
                            
                                    echomsg 'The current file will ' . (self.doAutoChecking(bufnr('')) ? '' : 'not ') . 'be checked automatically'
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000002 function! g:SyntasticModeMap._isOneFiletypeActive(filetypes) abort " {{{2
                                return !empty(filter(copy(a:filetypes), 'index(self._activeFiletypes, v:val) != -1'))
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticModeMap._noFiletypesArePassive(filetypes) abort " {{{2
                                return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/notifiers.vim
Sourced 2 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    2              0.000009 if exists('g:loaded_syntastic_notifiers') || !exists('g:loaded_syntastic_plugin')
    1              0.000000     finish
    1              0.000000 endif
    1              0.000002 let g:loaded_syntastic_notifiers = 1
                            
    1              0.000002 let g:SyntasticNotifiers = {}
                            
    1              0.000003 let s:_NOTIFIER_TYPES = ['signs', 'balloons', 'highlighting', 'cursor', 'autoloclist']
    1              0.000001 lockvar! s:_NOTIFIER_TYPES
                            
    1              0.000002 let s:_PERSISTENT_NOTIFIERS = ['signs', 'balloons']
    1              0.000001 lockvar! s:_PERSISTENT_NOTIFIERS
                            
                            " Public methods {{{1
                            
    1              0.000001 function! g:SyntasticNotifiers.Instance() abort " {{{2
                                if !exists('s:SyntasticNotifiersInstance')
                                    let s:SyntasticNotifiersInstance = copy(self)
                                    call s:SyntasticNotifiersInstance._initNotifiers()
                                endif
                            
                                return s:SyntasticNotifiersInstance
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticNotifiers.refresh(loclist) abort " {{{2
                                if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
                                for type in self._enabled_types
                                    let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                                    if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
                                        if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
                                            if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
                                            endif
                                            if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
                                                call self._notifier[type].refresh(a:loclist)
                                                let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
                                            endif
                                        else
                                            call self._notifier[type].refresh(a:loclist)
                                        endif
                                    endif
                                endfor
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticNotifiers.reset(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
                                for type in self._enabled_types
                                    let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
                                    if has_key(g:{class}, 'reset')
                                        call self._notifier[type].reset(a:loclist)
                                    endif
                            
                                    " also reset stamps
                                    if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                        let b:syntastic_private_{type}_stamp = []
                                    endif
                                endfor
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000001 function! g:SyntasticNotifiers._initNotifiers() abort " {{{2
                                let self._notifier = {}
                                for type in s:_NOTIFIER_TYPES
                                    let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                                    let self._notifier[type] = g:{class}.New()
                                endfor
                            
                                let self._enabled_types = copy(s:_NOTIFIER_TYPES)
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim
Sourced 2 times
Total time:   0.000267
 Self time:   0.000267

count  total (s)   self (s)
    2              0.000008 if exists('g:loaded_syntastic_registry') || !exists('g:loaded_syntastic_plugin')
    1              0.000001     finish
    1              0.000000 endif
    1              0.000002 let g:loaded_syntastic_registry = 1
                            
                            " Initialisation {{{1
                            
    1              0.000082 let s:_DEFAULT_CHECKERS = {
                                    \ 'actionscript':  ['mxmlc'],
                                    \ 'ada':           ['gcc'],
                                    \ 'ansible':       ['ansible_lint'],
                                    \ 'apiblueprint':  ['drafter'],
                                    \ 'applescript':   ['osacompile'],
                                    \ 'asciidoc':      ['asciidoc'],
                                    \ 'asl':           ['iasl'],
                                    \ 'asm':           ['gcc'],
                                    \ 'bro':           ['bro'],
                                    \ 'bemhtml':       ['bemhtmllint'],
                                    \ 'c':             ['gcc'],
                                    \ 'cabal':         ['cabal'],
                                    \ 'chef':          ['foodcritic'],
                                    \ 'cmake':         ['cmakelint'],
                                    \ 'co':            ['coco'],
                                    \ 'cobol':         ['cobc'],
                                    \ 'coffee':        ['coffee', 'coffeelint'],
                                    \ 'coq':           ['coqtop'],
                                    \ 'cpp':           ['gcc'],
                                    \ 'cs':            ['mcs'],
                                    \ 'css':           ['csslint'],
                                    \ 'cucumber':      ['cucumber'],
                                    \ 'cuda':          ['nvcc'],
                                    \ 'd':             ['dmd'],
                                    \ 'dart':          ['dartanalyzer'],
                                    \ 'docbk':         ['xmllint'],
                                    \ 'dockerfile':    ['dockerfile_lint'],
                                    \ 'dustjs':        ['swiffer'],
                                    \ 'elixir':        [],
                                    \ 'erlang':        ['escript'],
                                    \ 'eruby':         ['ruby'],
                                    \ 'fortran':       ['gfortran'],
                                    \ 'glsl':          ['cgc'],
                                    \ 'go':            [],
                                    \ 'haml':          ['haml'],
                                    \ 'handlebars':    ['handlebars'],
                                    \ 'haskell':       ['hdevtools', 'hlint'],
                                    \ 'haxe':          ['haxe'],
                                    \ 'help':          [],
                                    \ 'hss':           ['hss'],
                                    \ 'html':          ['tidy'],
                                    \ 'jade':          ['jade_lint'],
                                    \ 'java':          ['javac'],
                                    \ 'javascript':    ['jshint', 'jslint'],
                                    \ 'json':          ['jsonlint', 'jsonval'],
                                    \ 'julia':         [],
                                    \ 'less':          ['lessc'],
                                    \ 'lex':           ['flex'],
                                    \ 'limbo':         ['limbo'],
                                    \ 'lisp':          ['clisp'],
                                    \ 'llvm':          ['llvm'],
                                    \ 'lua':           ['luac'],
                                    \ 'markdown':      ['mdl'],
                                    \ 'matlab':        ['mlint'],
                                    \ 'mercury':       ['mmc'],
                                    \ 'nasm':          ['nasm'],
                                    \ 'nix':           ['nix'],
                                    \ 'nroff':         ['mandoc'],
                                    \ 'objc':          ['gcc'],
                                    \ 'objcpp':        ['gcc'],
                                    \ 'ocaml':         ['camlp4o'],
                                    \ 'perl':          ['perlcritic'],
                                    \ 'perl6':         [],
                                    \ 'php':           ['php', 'phpcs', 'phpmd'],
                                    \ 'po':            ['msgfmt'],
                                    \ 'pod':           ['podchecker'],
                                    \ 'puppet':        ['puppet', 'puppetlint'],
                                    \ 'pug':           ['pug_lint'],
                                    \ 'python':        ['python', 'flake8', 'pylint'],
                                    \ 'qml':           ['qmllint'],
                                    \ 'r':             [],
                                    \ 'rmd':           [],
                                    \ 'racket':        ['racket'],
                                    \ 'rnc':           ['rnv'],
                                    \ 'rst':           ['rst2pseudoxml'],
                                    \ 'ruby':          ['mri'],
                                    \ 'sass':          ['sass'],
                                    \ 'scala':         ['fsc', 'scalac'],
                                    \ 'scss':          ['sass', 'scss_lint'],
                                    \ 'sh':            ['sh', 'shellcheck'],
                                    \ 'slim':          ['slimrb'],
                                    \ 'sml':           ['smlnj'],
                                    \ 'spec':          ['rpmlint'],
                                    \ 'solidity':      ['solc'],
                                    \ 'sql':           ['sqlint'],
                                    \ 'stylus':        ['stylint'],
                                    \ 'svg':           [],
                                    \ 'tcl':           ['nagelfar'],
                                    \ 'tex':           ['lacheck', 'chktex'],
                                    \ 'texinfo':       ['makeinfo'],
                                    \ 'text':          [],
                                    \ 'trig':          ['rapper'],
                                    \ 'turtle':        ['rapper'],
                                    \ 'twig':          ['twiglint'],
                                    \ 'typescript':    [],
                                    \ 'verilog':       ['verilator'],
                                    \ 'vhdl':          ['ghdl'],
                                    \ 'vim':           ['vimlint'],
                                    \ 'vue':           ['pug_lint_vue', 'eslint'],
                                    \ 'xhtml':         ['tidy'],
                                    \ 'xml':           ['xmllint'],
                                    \ 'xslt':          ['xmllint'],
                                    \ 'xquery':        ['basex'],
                                    \ 'yacc':          ['bison'],
                                    \ 'yaml':          ['jsyaml'],
                                    \ 'yang':          ['pyang'],
                                    \ 'yara':          ['yarac'],
                                    \ 'z80':           ['z80syntaxchecker'],
                                    \ 'zpt':           ['zptlint'],
                                    \ 'zsh':           ['zsh'],
                                \ }
    1              0.000004 lockvar! s:_DEFAULT_CHECKERS
                            
    1              0.000007 let s:_DEFAULT_FILETYPE_MAP = {
                                    \ 'gentoo-metadata': 'xml',
                                    \ 'groff': 'nroff',
                                    \ 'lhaskell': 'haskell',
                                    \ 'litcoffee': 'coffee',
                                    \ 'mail': 'text',
                                    \ 'mkd': 'markdown',
                                    \ 'pe-puppet': 'puppet',
                                    \ 'sgml': 'docbk',
                                    \ 'sgmllnx': 'docbk',
                                \ }
    1              0.000001 lockvar! s:_DEFAULT_FILETYPE_MAP
                            
    1              0.000003 let s:_ECLIM_TYPES = [
                                    \ 'c',
                                    \ 'cpp',
                                    \ 'html',
                                    \ 'java',
                                    \ 'php',
                                    \ 'python',
                                    \ 'ruby',
                                \ ]
    1              0.000001 lockvar! s:_ECLIM_TYPES
                            
    1              0.000002 let s:_YCM_TYPES = [
                                    \ 'c',
                                    \ 'cpp',
                                    \ 'objc',
                                    \ 'objcpp',
                                \ ]
    1              0.000001 lockvar! s:_YCM_TYPES
                            
    1              0.000001 let g:SyntasticRegistry = {}
                            
                            " }}}1
                            
                            " Public methods {{{1
                            
                            " Note: Handling of filetype aliases: all public methods take aliases as
                            " parameters, all private methods take normalized filetypes.  Public methods
                            " are thus supposed to normalize filetypes before calling private methods.
                            
    1              0.000002 function! g:SyntasticRegistry.Instance() abort " {{{2
                                if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
                                return s:SyntasticRegistryInstance
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticRegistry.CreateAndRegisterChecker(args) abort " {{{2
                                let registry = g:SyntasticRegistry.Instance()
                            
                                if has_key(a:args, 'redirect')
                                    let [ft, name] = split(a:args['redirect'], '/')
                                    call registry._loadCheckersFor(ft, 1)
                            
                                    let clone = get(registry._checkerMap[ft], name, {})
                                    if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
                                    let checker = g:SyntasticChecker.New(a:args, clone)
                                else
                                    let checker = g:SyntasticChecker.New(a:args)
                                endif
                                call registry._registerChecker(checker)
                            endfunction " }}}2
                            
                            " Given a list of checker names hints_list, return a map name --> checker.
                            " If hints_list is empty, user settings are are used instead. Checkers are
                            " not checked for availability (that is, the corresponding IsAvailable() are
                            " not run).
    1              0.000001 function! g:SyntasticRegistry.getCheckers(ftalias, hints_list) abort " {{{2
                                let ftlist = self.resolveFiletypes(a:ftalias)
                            
                                let names =
                                    \ !empty(a:hints_list) ? a:hints_list :
                                    \ exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
                                let cnames = []
                                if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
                                else
                                    for ft in ftlist
                                        call self._sanityCheck(ft)
                                        let defs =
                                            \ exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers :
                                            \ get(s:_DEFAULT_CHECKERS, ft, [])
                                        call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
                                    endfor
                                endif
                                let cnames = syntastic#util#unique(cnames)
                            
                                for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
                                    call self._loadCheckersFor(ft, 0)
                                endfor
                            
                                return self._filterCheckersByName(cnames)
                            endfunction " }}}2
                            
                            " Same as getCheckers(), but keep only the available checkers.  This runs the
                            " corresponding IsAvailable() functions for all checkers.
    1              0.000003 function! g:SyntasticRegistry.getCheckersAvailable(ftalias, hints_list) abort " {{{2
                                return filter(self.getCheckers(a:ftalias, a:hints_list), 'v:val.isAvailable()')
                            endfunction " }}}2
                            
                            " Same as getCheckers(), but keep only the checkers that are available and
                            " disabled.  This runs the corresponding IsAvailable() functions for all checkers.
    1              0.000001 function! g:SyntasticRegistry.getCheckersDisabled(ftalias, hints_list) abort " {{{2
                                return filter(self.getCheckers(a:ftalias, a:hints_list), 'v:val.isDisabled() && v:val.isAvailable()')
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticRegistry.getKnownFiletypes() abort " {{{2
                                let types = keys(s:_DEFAULT_CHECKERS)
                            
                                call extend(types, keys(s:_DEFAULT_FILETYPE_MAP))
                            
                                if exists('g:syntastic_filetype_map')
                                    call extend(types, keys(g:syntastic_filetype_map))
                                endif
                            
                                if exists('g:syntastic_extra_filetypes') && type(g:syntastic_extra_filetypes) == type([])
                                    call extend(types, g:syntastic_extra_filetypes)
                                endif
                            
                                return syntastic#util#unique(types)
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticRegistry.getNamesOfAvailableCheckers(ftalias) abort " {{{2
                                let ft = s:_normalise_filetype(a:ftalias)
                                call self._loadCheckersFor(ft, 0)
                                return keys(filter( copy(self._checkerMap[ft]), 'v:val.isAvailable()' ))
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticRegistry.resolveFiletypes(ftalias) abort " {{{2
                                return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticRegistry.echoInfoFor(ftalias_list) abort " {{{2
                                let ft_list = syntastic#util#unique(self.resolveFiletypes(empty(a:ftalias_list) ? &filetype : a:ftalias_list[0]))
                                if len(ft_list) != 1
                                    let available = []
                                    let active = []
                                    let disabled = []
                            
                                    for ft in ft_list
                                        call extend(available, map( self.getNamesOfAvailableCheckers(ft), 'ft . "/" . v:val' ))
                                        call extend(active, map( self.getCheckersAvailable(ft, []), 'ft . "/" . v:val.getName()' ))
                                        call extend(disabled, map( self.getCheckersDisabled(ft, []), 'ft . "/" . v:val.getName()' ))
                                    endfor
                                else
                                    let ft = ft_list[0]
                                    let available = self.getNamesOfAvailableCheckers(ft)
                                    let active = map(self.getCheckersAvailable(ft, []), 'ft ==# v:val.getFiletype() ? v:val.getName() : v:val.getCName()')
                                    let disabled = map(self.getCheckersDisabled(ft, []), 'ft ==# v:val.getFiletype() ? v:val.getName() : v:val.getCName()')
                                endif
                            
                                let cnt = len(available)
                                let plural = cnt != 1 ? 's' : ''
                                let cklist = cnt ? join(sort(available)) : '-'
                                echomsg 'Available checker' . plural . ': ' . cklist
                            
                                let cnt = len(active)
                                let plural = cnt != 1 ? 's' : ''
                                let cklist = cnt ? join(active) : '-'
                                echomsg 'Currently enabled checker' . plural . ': ' . cklist
                            
                                let cnt = len(disabled)
                                let plural = cnt != 1 ? 's' : ''
                                if len(disabled)
                                    let cklist = join(sort(disabled, 's:_compare_checker_names'))
                                    echomsg 'Checker' . plural . ' disabled for security reasons: ' . cklist
                                endif
                            
                                " Eclim feels entitled to mess with syntastic's variables {{{3
                                if exists(':EclimValidate') && get(g:, 'EclimFileTypeValidate', 1)
                                    let disabled = filter(copy(ft_list), 's:_disabled_by_eclim(v:val)')
                                    let cnt = len(disabled)
                                    if cnt
                                        let plural = cnt != 1 ? 's' : ''
                                        let cklist = join(disabled, ', ')
                                        echomsg 'Checkers for filetype' . plural . ' ' . cklist . ' possibly disabled by Eclim'
                                    endif
                                endif
                                " }}}3
                            
                                " So does YouCompleteMe {{{3
                                if exists('g:loaded_youcompleteme') && get(g:, 'ycm_show_diagnostics_ui', get(g:, 'ycm_register_as_syntastic_checker', 1))
                                    let disabled = filter(copy(ft_list), 's:_disabled_by_ycm(v:val)')
                                    let cnt = len(disabled)
                                    if cnt
                                        let plural = cnt != 1 ? 's' : ''
                                        let cklist = join(disabled, ', ')
                                        echomsg 'Checkers for filetype' . plural . ' ' . cklist . ' possibly disabled by YouCompleteMe'
                                    endif
                                endif
                                " }}}3
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
    1              0.000003 function! g:SyntasticRegistry._registerChecker(checker) abort " {{{2
                                let ft = a:checker.getFiletype()
                                if !has_key(self._checkerMap, ft)
                                    let self._checkerMap[ft] = {}
                                endif
                            
                                let name = a:checker.getName()
                                if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
                                endif
                            
                                let self._checkerMap[ft][name] = a:checker
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticRegistry._findChecker(cname) abort " {{{2
                                let sep_idx = stridx(a:cname, '/')
                                if sep_idx > 0
                                    let ft = a:cname[: sep_idx-1]
                                    let name = a:cname[sep_idx+1 :]
                                else
                                    let ft = &filetype
                                    let name = a:cname
                                endif
                                return get(self._checkerMap[ft], name, {})
                            endfunction "}}}2
                            
    1              0.000001 function! g:SyntasticRegistry._filterCheckersByName(cnames) abort " {{{2
                                return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticRegistry._loadCheckersFor(filetype, force) abort " {{{2
                                if !a:force && has_key(self._checkerMap, a:filetype)
                                    return
                                endif
                            
                                execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
                                if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif
                            endfunction " }}}2
                            
                            " Check for obsolete variable g:syntastic_<filetype>_checker
    1              0.000001 function! g:SyntasticRegistry._sanityCheck(filetype) abort " {{{2
                                if exists('g:syntastic_' . a:filetype . '_checkers') &&
                                    \ type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
                                endif
                            
                                if exists('g:syntastic_' . a:filetype . '_checker') &&
                                    \ !exists('g:syntastic_' . a:filetype . '_checkers') &&
                                    \ type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
                            "resolve filetype aliases, and replace - with _ otherwise we cant name
                            "syntax checker functions legally for filetypes like "gentoo-metadata"
    1              0.000002 function! s:_normalise_filetype(ftalias) abort " {{{2
                                let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
                                let ft = get(g:syntastic_filetype_map, ft, ft)
                                let ft = substitute(ft, '\m-', '_', 'g')
                                return ft
                            endfunction " }}}2
                            
    1              0.000002 function! s:_disabled_by_eclim(filetype) abort " {{{2
                                if index(s:_ECLIM_TYPES, a:filetype) >= 0
                                    let lang = toupper(a:filetype[0]) . a:filetype[1:]
                                    let ft = a:filetype !=# 'cpp' ? lang : 'C'
                                    return get(g:, 'Eclim' . lang . 'Validate', 1) && !get(g:, 'Eclim' . ft . 'SyntasticEnabled', 0)
                                endif
                            
                                return 0
                            endfunction " }}}2
                            
    1              0.000001 function! s:_disabled_by_ycm(filetype) abort " {{{2
                                return index(s:_YCM_TYPES, a:filetype) >= 0
                            endfunction " }}}2
                            
    1              0.000001 function! s:_compare_checker_names(a, b) abort " {{{2
                                if a:a ==# a:b
                                    return 0
                                endif
                            
                                if stridx(a:a, '/') < 0
                                    if stridx(a:b, '/') < 0
                                        return a:a < a:b ? -1 : 1
                                    else
                                        return -1
                                    endif
                                else
                                    if stridx(a:b, '/') < 0
                                        return 1
                                    else
                                        return a:a < a:b ? -1 : 1
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/signs.vim
Sourced 2 times
Total time:   0.000084
 Self time:   0.000084

count  total (s)   self (s)
    2              0.000010 if exists('g:loaded_syntastic_notifier_signs') || !exists('g:loaded_syntastic_plugin')
    1              0.000000     finish
    1              0.000001 endif
    1              0.000002 let g:loaded_syntastic_notifier_signs = 1
                            
                            " Initialisation {{{1
                            
                            " start counting sign ids at 5000, start here to hopefully avoid conflicting
                            " with any other code that places signs (not sure if this precaution is
                            " actually needed)
    1              0.000002 let s:first_sign_id = 5000
    1              0.000002 let s:next_sign_id = s:first_sign_id
                            
    1              0.000001 let g:SyntasticSignsNotifier = {}
                            
    1              0.000001 let s:setup_done = 0
                            
                            " }}}1
                            
                            " Public methods {{{1
                            
    1              0.000002 function! g:SyntasticSignsNotifier.New() abort " {{{2
                                let newObj = copy(self)
                                return newObj
                            endfunction " }}}2
                            
    1              0.000001 function! g:SyntasticSignsNotifier.enabled() abort " {{{2
                                return has('signs') && syntastic#util#var('enable_signs')
                            endfunction " }}}2
                            
    1              0.000002 function! g:SyntasticSignsNotifier.refresh(loclist) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
                                let old_signs = copy(self._bufSignIds())
                                if self.enabled()
                                    if !s:setup_done
                                        call self._setup()
                                        let s:setup_done = 1
                                        lockvar s:setup_done
                                    endif
                            
                                    call self._signErrors(a:loclist)
                                endif
                                call self._removeSigns(old_signs)
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private methods {{{1
                            
                            " One time setup: define our own sign types and highlighting
    1              0.000001 function! g:SyntasticSignsNotifier._setup() abort " {{{2
                                if has('signs')
                                    if !hlexists('SyntasticErrorSign')
                                        highlight link SyntasticErrorSign error
                                    endif
                                    if !hlexists('SyntasticWarningSign')
                                        highlight link SyntasticWarningSign todo
                                    endif
                                    if !hlexists('SyntasticStyleErrorSign')
                                        highlight link SyntasticStyleErrorSign SyntasticErrorSign
                                    endif
                                    if !hlexists('SyntasticStyleWarningSign')
                                        highlight link SyntasticStyleWarningSign SyntasticWarningSign
                                    endif
                                    if !hlexists('SyntasticStyleErrorLine')
                                        highlight link SyntasticStyleErrorLine SyntasticErrorLine
                                    endif
                                    if !hlexists('SyntasticStyleWarningLine')
                                        highlight link SyntasticStyleWarningLine SyntasticWarningLine
                                    endif
                            
                                    " define the signs used to display syntax and style errors/warns
                                    execute 'sign define SyntasticError text=' . g:syntastic_error_symbol .
                                        \ ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
                                    execute 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol .
                                        \ ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
                                    execute 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol .
                                        \ ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
                                    execute 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol .
                                        \ ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
                                endif
                            endfunction " }}}2
                            
                            " Place signs by all syntax errors in the buffer
    1              0.000001 function! g:SyntasticSignsNotifier._signErrors(loclist) abort " {{{2
                                let loclist = a:loclist
                                if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " Remove the signs with the given ids from this buffer
    1              0.000002 function! g:SyntasticSignsNotifier._removeSigns(ids) abort " {{{2
                                if has('signs')
                                    for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
                                endif
                            endfunction " }}}2
                            
                            " Get all the ids of the SyntaxError signs in the buffer
    1              0.000001 function! g:SyntasticSignsNotifier._bufSignIds() abort " {{{2
                                if !exists('b:syntastic_private_sign_ids')
                                    let b:syntastic_private_sign_ids = []
                                endif
                                return b:syntastic_private_sign_ids
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim
Sourced 1 time
Total time:   0.007097
 Self time:   0.001378

count  total (s)   self (s)
                            "============================================================================
                            "File:        syntastic.vim
                            "Description: Vim plugin for on the fly syntax checking.
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000002 if exists('g:loaded_syntastic_plugin') || &compatible
                                finish
    1              0.000001 endif
    1              0.000002 let g:loaded_syntastic_plugin = 1
                            
    1              0.000003 if has('reltime')
    1              0.000002     let g:_SYNTASTIC_START = reltime()
    1              0.000002     lockvar! g:_SYNTASTIC_START
    1              0.000000 endif
                            
    1              0.000001 let g:_SYNTASTIC_VERSION = '3.10.0-8'
    1              0.000001 lockvar g:_SYNTASTIC_VERSION
                            
                            " Sanity checks {{{1
                            
    1              0.000003 if v:version < 700 || (v:version == 700 && !has('patch175'))
                                call syntastic#log#error('need Vim version 7.0.175 or later')
                                finish
    1              0.000001 endif
                            
    9              0.000010 for s:feature in [
                                        \ 'autocmd',
                                        \ 'eval',
                                        \ 'file_in_path',
                                        \ 'modify_fname',
                                        \ 'quickfix',
                                        \ 'reltime',
                                        \ 'statusline',
                                        \ 'user_commands',
                                    \ ]
    8              0.000015     if !has(s:feature)
                                    call syntastic#log#error('need Vim compiled with feature ' . s:feature)
                                    finish
    8              0.000003     endif
    9              0.000005 endfor
                            
    1   0.000470   0.000034 let s:_running_windows = syntastic#util#isRunningWindows()
    1              0.000002 lockvar s:_running_windows
                            
    1              0.000002 if !exists('g:syntastic_shell')
    1              0.000002     let g:syntastic_shell = &shell
    1              0.000000 endif
                            
    1              0.000001 if s:_running_windows
                                let g:_SYNTASTIC_UNAME = 'Windows'
    1              0.000011 elseif executable('uname')
    1              0.000001     try
    1   0.003962   0.000015         let g:_SYNTASTIC_UNAME = split(syntastic#util#system('uname'), "\n")[0]
                                catch /\m^E145$/
                                    call syntastic#log#error("can't run in rvim")
                                    finish
                                catch /\m^E484$/
                                    call syntastic#log#error("can't run external programs (misconfigured shell options?)")
                                    finish
                                catch /\m^E684$/
                                    let g:_SYNTASTIC_UNAME = 'Unknown'
    1              0.000001     endtry
                            else
                                let g:_SYNTASTIC_UNAME = 'Unknown'
    1              0.000001 endif
    1              0.000001 lockvar g:_SYNTASTIC_UNAME
                            
                            " XXX Ugly hack to make g:_SYNTASTIC_UNAME available to :SyntasticInfo without
                            " polluting session namespaces
    1              0.000014 let g:syntastic_version =
                                \ g:_SYNTASTIC_VERSION .
                                \ ' (Vim ' . v:version . (has('nvim') ? ', Neovim' : '') . ', ' .
                                \ g:_SYNTASTIC_UNAME .
                                \ (has('gui') ? ', GUI' : '') . ')'
    1              0.000001 lockvar g:syntastic_version
                            
                            " }}}1
                            
                            " Defaults {{{1
                            
    1              0.000031 let g:_SYNTASTIC_DEFAULTS = {
                                    \ 'aggregate_errors':         0,
                                    \ 'always_populate_loc_list': 0,
                                    \ 'auto_jump':                0,
                                    \ 'auto_loc_list':            2,
                                    \ 'check_on_open':            0,
                                    \ 'check_on_wq':              1,
                                    \ 'cursor_columns':           1,
                                    \ 'debug':                    0,
                                    \ 'echo_current_error':       1,
                                    \ 'enable_balloons':          1,
                                    \ 'enable_highlighting':      1,
                                    \ 'enable_signs':             1,
                                    \ 'error_symbol':             '>>',
                                    \ 'exit_checks':              !(s:_running_windows && syntastic#util#var('shell', &shell) =~? '\m\<cmd\.exe$'),
                                    \ 'filetype_map':             {},
                                    \ 'full_redraws':             !(has('gui_running') || has('gui_macvim')),
                                    \ 'id_checkers':              1,
                                    \ 'ignore_extensions':        '\c\v^([gx]?z|lzma|bz2)$',
                                    \ 'ignore_files':             [],
                                    \ 'loc_list_height':          10,
                                    \ 'nested_autocommands':      0,
                                    \ 'quiet_messages':           {},
                                    \ 'reuse_loc_lists':          1,
                                    \ 'shell':                    &shell,
                                    \ 'sort_aggregated_errors':   1,
                                    \ 'stl_format':               '[Syntax: line:%F (%t)]',
                                    \ 'style_error_symbol':       'S>',
                                    \ 'style_warning_symbol':     'S>',
                                    \ 'warning_symbol':           '>>'
                                \ }
    1              0.000002 lockvar! g:_SYNTASTIC_DEFAULTS
                            
   30              0.000030 for s:key in keys(g:_SYNTASTIC_DEFAULTS)
   29              0.000052     if !exists('g:syntastic_' . s:key)
   24              0.000065         let g:syntastic_{s:key} = copy(g:_SYNTASTIC_DEFAULTS[s:key])
   29              0.000012     endif
   30              0.000014 endfor
                            
    1              0.000002 if exists('g:syntastic_quiet_warnings')
                                call syntastic#log#oneTimeWarn("variable g:syntastic_quiet_warnings is deprecated, please use let g:syntastic_quiet_messages = {'level': 'warnings'} instead")
                                if g:syntastic_quiet_warnings
                                    let s:quiet_warnings = get(g:syntastic_quiet_messages, 'type', [])
                                    if type(s:quiet_warnings) != type([])
                                        let s:quiet_warnings = [s:quiet_warnings]
                                    endif
                                    call add(s:quiet_warnings, 'warnings')
                                    let g:syntastic_quiet_messages['type'] = s:quiet_warnings
                                endif
    1              0.000001 endif
                            
                            " }}}1
                            
                            " Debug {{{1
                            
    1              0.000004 let g:_SYNTASTIC_SHELL_OPTIONS = [
                                    \ 'shell',
                                    \ 'shellcmdflag',
                                    \ 'shellpipe',
                                    \ 'shellquote',
                                    \ 'shellredir',
                                    \ 'shelltemp',
                                    \ 'shellxquote'
                                \ ]
    4              0.000006 for s:feature in [
                                    \ 'autochdir',
                                    \ 'shellslash',
                                    \ 'shellxescape',
                                \ ]
                            
    3              0.000006     if exists('+' . s:feature)
    2              0.000005         call add(g:_SYNTASTIC_SHELL_OPTIONS, s:feature)
    3              0.000001     endif
    4              0.000003 endfor
    1              0.000001 lockvar! g:_SYNTASTIC_SHELL_OPTIONS
                            
                            " debug constants
    1              0.000002 let     g:_SYNTASTIC_DEBUG_TRACE         = 1
    1              0.000001 lockvar g:_SYNTASTIC_DEBUG_TRACE
    1              0.000001 let     g:_SYNTASTIC_DEBUG_LOCLIST       = 2
    1              0.000001 lockvar g:_SYNTASTIC_DEBUG_LOCLIST
    1              0.000002 let     g:_SYNTASTIC_DEBUG_NOTIFICATIONS = 4
    1              0.000001 lockvar g:_SYNTASTIC_DEBUG_NOTIFICATIONS
    1              0.000001 let     g:_SYNTASTIC_DEBUG_AUTOCOMMANDS  = 8
    1              0.000001 lockvar g:_SYNTASTIC_DEBUG_AUTOCOMMANDS
    1              0.000002 let     g:_SYNTASTIC_DEBUG_VARIABLES     = 16
    1              0.000000 lockvar g:_SYNTASTIC_DEBUG_VARIABLES
    1              0.000001 let     g:_SYNTASTIC_DEBUG_CHECKERS      = 32
    1              0.000001 lockvar g:_SYNTASTIC_DEBUG_CHECKERS
                            
                            " }}}1
                            
    1   0.001519   0.000359 runtime! plugin/syntastic/*.vim
                            
    1   0.000019   0.000004 let s:registry = g:SyntasticRegistry.Instance()
    1   0.000140   0.000003 let s:notifiers = g:SyntasticNotifiers.Instance()
    1   0.000027   0.000003 let s:modemap = g:SyntasticModeMap.Instance()
                            
    1              0.000002 let s:_check_stack = []
    1              0.000001 let s:_quit_pre = []
                            
                            " Commands {{{1
                            
                            " @vimlint(EVL103, 1, a:cursorPos)
                            " @vimlint(EVL103, 1, a:cmdLine)
                            " @vimlint(EVL103, 1, a:argLead)
    1              0.000003 function! s:CompleteCheckerName(argLead, cmdLine, cursorPos) abort " {{{2
                                let names = []
                            
                                let sep_idx = stridx(a:argLead, '/')
                                if sep_idx >= 1
                                    let ft = a:argLead[: sep_idx-1]
                                    call extend(names, map( s:registry.getNamesOfAvailableCheckers(ft), 'ft . "/" . v:val' ))
                                else
                                    for ft in s:registry.resolveFiletypes(&filetype)
                                        call extend(names, s:registry.getNamesOfAvailableCheckers(ft))
                                    endfor
                                    call extend(names, map( copy(s:registry.getKnownFiletypes()), 'v:val . "/"' ))
                                endif
                            
                                return join(names, "\n")
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:cursorPos)
                            " @vimlint(EVL103, 0, a:cmdLine)
                            " @vimlint(EVL103, 0, a:argLead)
                            
                            
                            " @vimlint(EVL103, 1, a:cursorPos)
                            " @vimlint(EVL103, 1, a:cmdLine)
                            " @vimlint(EVL103, 1, a:argLead)
    1              0.000003 function! s:CompleteFiletypes(argLead, cmdLine, cursorPos) abort " {{{2
                                return join(s:registry.getKnownFiletypes(), "\n")
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:cursorPos)
                            " @vimlint(EVL103, 0, a:cmdLine)
                            " @vimlint(EVL103, 0, a:argLead)
                            
    1              0.000012 command! -bar -nargs=* -complete=custom,s:CompleteCheckerName SyntasticCheck call SyntasticCheck(<f-args>)
    1              0.000006 command! -bar -nargs=? -complete=custom,s:CompleteFiletypes   SyntasticInfo  call SyntasticInfo(<f-args>)
    1              0.000005 command! -bar Errors              call SyntasticErrors()
    1              0.000004 command! -bar SyntasticReset      call SyntasticReset()
    1              0.000005 command! -bar SyntasticToggleMode call SyntasticToggleMode()
    1              0.000005 command! -bar SyntasticSetLoclist call SyntasticSetLoclist()
                            
    1              0.000010 command! SyntasticJavacEditClasspath runtime! syntax_checkers/java/*.vim | SyntasticJavacEditClasspath
    1              0.000010 command! SyntasticJavacEditConfig    runtime! syntax_checkers/java/*.vim | SyntasticJavacEditConfig
                            
                            " }}}1
                            
                            " Public API {{{1
                            
    1              0.000002 function! SyntasticCheck(...) abort " {{{2
                                call s:UpdateErrors(bufnr(''), 0, a:000)
                                call syntastic#util#redraw(g:syntastic_full_redraws)
                            endfunction " }}}2
                            
    1              0.000001 function! SyntasticInfo(...) abort " {{{2
                                call s:modemap.modeInfo(a:000)
                                call s:registry.echoInfoFor(a:000)
                                call s:_explain_skip(a:000)
                                call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
                                call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
                            endfunction " }}}2
                            
    1              0.000001 function! SyntasticErrors() abort " {{{2
                                call g:SyntasticLoclist.current().show()
                            endfunction " }}}2
                            
    1              0.000001 function! SyntasticReset() abort " {{{2
                                call s:ClearCache(bufnr(''))
                                call s:notifiers.refresh(g:SyntasticLoclist.New([]))
                            endfunction " }}}2
                            
    1              0.000002 function! SyntasticToggleMode() abort " {{{2
                                call s:modemap.toggleMode()
                                call s:ClearCache(bufnr(''))
                                call s:notifiers.refresh(g:SyntasticLoclist.New([]))
                                call s:modemap.echoMode()
                            endfunction " }}}2
                            
    1              0.000001 function! SyntasticSetLoclist() abort " {{{2
                                call g:SyntasticLoclist.current().setloclist(0)
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Autocommands {{{1
                            
    1              0.000003 augroup syntastic
    1              0.000149     autocmd!
    1              0.000006     autocmd VimEnter    * call s:VimEnterHook()
    1              0.000004     autocmd BufEnter    * call s:BufEnterHook(expand('<afile>', 1))
    1              0.000003     autocmd BufWinEnter * call s:BufWinEnterHook(expand('<afile>', 1))
    1              0.000001 augroup END
                            
    1              0.000001 if g:syntastic_nested_autocommands
                                augroup syntastic
                                    autocmd BufReadPost  * nested call s:BufReadPostHook(expand('<afile>', 1))
                                    autocmd BufWritePost * nested call s:BufWritePostHook(expand('<afile>', 1))
                                augroup END
    1              0.000001 else
    1              0.000001     augroup syntastic
    1              0.000004         autocmd BufReadPost  * call s:BufReadPostHook(expand('<afile>', 1))
    1              0.000003         autocmd BufWritePost * call s:BufWritePostHook(expand('<afile>', 1))
    1              0.000001     augroup END
    1              0.000000 endif
                            
    1              0.000002 if exists('##QuitPre')
                                " QuitPre was added in Vim 7.3.544
    1              0.000001     augroup syntastic
    1              0.000003         autocmd QuitPre * call s:QuitPreHook(expand('<afile>', 1))
    1              0.000001     augroup END
    1              0.000001 endif
                            
    1              0.000002 function! s:BufReadPostHook(fname) abort " {{{2
                                let buf = syntastic#util#fname2buf(a:fname)
                                if g:syntastic_check_on_open && buf > 0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                        \ 'autocmd: BufReadPost, buffer ' . buf . ' = ' . string(a:fname))
                                    if index(s:_check_stack, buf) == -1
                                        call add(s:_check_stack, buf)
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! s:BufWritePostHook(fname) abort " {{{2
                                let buf = syntastic#util#fname2buf(a:fname)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                    \ 'autocmd: BufWritePost, buffer ' . buf . ' = ' . string(a:fname))
                                call s:UpdateErrors(buf, 1, [])
                            endfunction " }}}2
                            
    1              0.000002 function! s:BufEnterHook(fname) abort " {{{2
                                let buf = syntastic#util#fname2buf(a:fname)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                    \ 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
                                if buf > 0 && getbufvar(buf, '&buftype') ==# ''
                                    let idx = index(reverse(copy(s:_check_stack)), buf)
                                    if idx >= 0
                                        if !has('vim_starting')
                                            call remove(s:_check_stack, -idx - 1)
                                            call s:UpdateErrors(buf, 1, [])
                                        endif
                                    elseif &buftype ==# ''
                                        call s:notifiers.refresh(g:SyntasticLoclist.current())
                                    endif
                                elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! s:BufWinEnterHook(fname) abort " {{{2
                                let buf = syntastic#util#fname2buf(a:fname)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                    \ 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
                                if buf > 0 && getbufvar(buf, '&buftype') ==# ''
                                    let idx = index(reverse(copy(s:_check_stack)), buf)
                                    if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
                                    endif
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! s:VimEnterHook() abort " {{{2
                                let buf = bufnr('')
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS,
                                    \ 'autocmd: VimEnter, buffer ' . buf . ' = ' . string(bufname(buf)) . ', &buftype = ' . string(&buftype))
                                let idx = index(reverse(copy(s:_check_stack)), buf)
                                if idx >= 0 && getbufvar(buf, '&buftype') ==# ''
                                    call remove(s:_check_stack, -idx - 1)
                                    call s:UpdateErrors(buf, 1, [])
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! s:QuitPreHook(fname) abort " {{{2
                                let buf = syntastic#util#fname2buf(a:fname)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
                                if !syntastic#util#var('check_on_wq')
                                    call syntastic#util#setWids()
                                    call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
                                endif
                            
                                if !empty(get(w:, 'syntastic_loclist_set', []))
                                    call SyntasticLoclistHide()
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Main {{{1
                            
                            "refresh and redraw all the error info for this buf when saving or reading
    1              0.000002 function! s:UpdateErrors(buf, auto_invoked, checker_names) abort " {{{2
                                call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
                                call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
                                call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') .
                                    \ ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
                                call s:modemap.synch()
                            
                                if s:_skip_file(a:buf)
                                    return
                                endif
                            
                                let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
                                if run_checks
                                    call s:CacheErrors(a:buf, a:checker_names)
                                    call syntastic#util#setLastTick(a:buf)
                                elseif a:auto_invoked
                                    return
                                endif
                            
                                let loclist = g:SyntasticLoclist.current(a:buf)
                            
                                if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
                                endif
                            
                                " populate loclist and jump {{{3
                                let do_jump = syntastic#util#var('auto_jump') + 0
                                if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
                                elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
                                elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
                                endif
                            
                                if syntastic#util#var('always_populate_loc_list') || do_jump
                                    call loclist.setloclist(1)
                                    if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
                                    endif
                                endif
                                " }}}3
                            
                                call s:notifiers.refresh(loclist)
                            endfunction " }}}2
                            
                            "clear the loc list for the buffer
    1              0.000002 function! s:ClearCache(buf) abort " {{{2
                                let loclist = g:SyntasticLoclist.current(a:buf)
                                call s:notifiers.reset(loclist)
                                call loclist.destroy()
                            endfunction " }}}2
                            
                            "detect and cache all syntax errors in this buffer
    1              0.000002 function! s:CacheErrors(buf, checker_names) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' .
                                    \ (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                                call s:ClearCache(a:buf)
                                let newLoclist = g:SyntasticLoclist.New([])
                                call newLoclist.setOwner(a:buf)
                            
                                if !s:_skip_file(a:buf)
                                    " debug logging {{{3
                                    call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
                                    if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
                                    endif
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
                                    let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
                                    let aggregate_errors =
                                        \ syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
                                    let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
                                    let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
                                    let names = []
                                    let unavailable_checkers = 0
                                    for checker in clist
                                        let cname = checker.getCName()
                                        if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
                                        let loclist = checker.getLocList()
                            
                                        if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            call newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
                                    endfor
                            
                                    " set names {{{3
                                    if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
                                    if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
                                    if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
                                    endif
                                endif
                            
                                call newLoclist.deploy()
                            endfunction " }}}2
                            
                            "Emulates the :lmake command. Sets up the make environment according to the
                            "options given, runs make, resets the environment, returns the location list
                            "
                            "a:options can contain the following keys:
                            "    'makeprg'
                            "    'errorformat'
                            "
                            "The corresponding options are set for the duration of the function call. They
                            "are set with :let, so dont escape spaces.
                            "
                            "a:options may also contain:
                            "   'defaults' - a dict containing default values for the returned errors
                            "   'subtype' - all errors will be assigned the given subtype
                            "   'preprocess' - a function to be applied to the error file before parsing errors
                            "   'postprocess' - a list of functions to be applied to the error list
                            "   'cwd' - change directory to the given path before running the checker
                            "   'env' - environment variables to set before running the checker
                            "   'returns' - a list of valid exit codes for the checker
                            " @vimlint(EVL102, 1, l:env_save)
    1              0.000001 function! SyntasticMake(options) abort " {{{2
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
                                let old_local_errorformat = &l:errorformat
                                let old_errorformat = &errorformat
                                let old_cwd = getcwd()
                                " }}}3
                            
                                if has_key(a:options, 'errorformat')
                                    let &errorformat = a:options['errorformat']
                                    set errorformat<
                                endif
                            
                                if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
                                let env_save = {}
                                if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_][a-z0-9_]*$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
                                " }}}3
                            
                                let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
                                if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
                                let bailout =
                                    \ syntastic#util#var('exit_checks') &&
                                    \ has_key(a:options, 'returns') &&
                                    \ index(a:options['returns'], v:shell_error) == -1
                            
                                if !bailout
                                    if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
                                    elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
                                    endif
                                    noautocmd lgetexpr err_lines
                            
                                    let errors = deepcopy(getloclist(0))
                            
                                    if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
                                    endif
                            
                                    try
                                        silent lolder
                                    catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
                                        call setloclist(0, [], 'r')
                                        try
                                            " Vim 7.4.2200 or later
                                            call setloclist(0, [], 'r', { 'title': '' })
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            " do nothing
                                        endtry
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
                                    endtry
                                else
                                    let errors = []
                                endif
                            
                                " restore options {{{3
                                let &errorformat = old_errorformat
                                let &l:errorformat = old_local_errorformat
                                " }}}3
                            
                                if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
                                if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
                                endif
                            
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
                                if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
                                if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
                                if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
                                endif
                            
                                return errors
                            endfunction " }}}2
                            " @vimlint(EVL102, 0, l:env_save)
                            
                            "return a string representing the state of buffer according to
                            "g:syntastic_stl_format
                            "
                            "return '' if no errors are cached for the buffer
    1              0.000002 function! SyntasticStatuslineFlag() abort " {{{2
                                return g:SyntasticLoclist.current().getStatuslineFlag()
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000002 function! s:_ignore_file(filename) abort " {{{2
                                let fname = fnamemodify(a:filename, ':p')
                                for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
                                return 0
                            endfunction " }}}2
                            
    1              0.000001 function! s:_is_quitting(buf) abort " {{{2
                                let quitting = 0
                                if exists('w:syntastic_wid')
                                    let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
                                    let idx = index(s:_quit_pre, key)
                                    if idx >= 0
                                        call remove(s:_quit_pre, idx)
                                        let quitting = 1
                                    endif
                                endif
                            
                                return quitting
                            endfunction " }}}2
                            
                            " Skip running in special buffers
    1              0.000002 function! s:_skip_file(buf) abort " {{{2
                                let fname = bufname(a:buf)
                                let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') ||
                                    \ (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') ||
                                    \ getwinvar(0, '&previewwindow') || s:_ignore_file(fname) ||
                                    \ fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
                                if skip
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
                                endif
                                return skip
                            endfunction " }}}2
                            
                            " Explain why checks will be skipped for the current file
    1              0.000002 function! s:_explain_skip(filetypes) abort " {{{2
                                let buf = bufnr('')
                                if empty(a:filetypes) && s:_skip_file(buf)
                                    let why = []
                                    let fname = bufname(buf)
                                    let bt = getbufvar(buf, '&buftype')
                            
                                    if s:_is_quitting(buf)
                                        call add(why, 'quitting buffer')
                                    endif
                                    if getbufvar(buf, 'syntastic_skip_checks')
                                        call add(why, 'b:syntastic_skip_checks set')
                                    endif
                                    if bt !=# ''
                                        call add(why, 'buftype = ' . string(&buftype))
                                    endif
                                    if !filereadable(fname)
                                        call add(why, 'file not readable / not local')
                                    endif
                                    if getwinvar(0, '&diff')
                                        call add(why, 'diff mode')
                                    endif
                                    if getwinvar(0, '&previewwindow')
                                        call add(why, 'preview window')
                                    endif
                                    if s:_ignore_file(fname)
                                        call add(why, 'filename matching g:syntastic_ignore_files')
                                    endif
                                    if fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
                                        call add(why, 'extension matching g:syntastic_ignore_extensions')
                                    endif
                            
                                    echomsg 'The current file will not be checked (' . join(why, ', ') . ')'
                                endif
                            endfunction " }}}2
                            
                            " Take a list of errors and add default values to them from a:options
    1              0.000002 function! s:_add_to_errors(errors, options) abort " {{{2
                                for err in a:errors
                                    for key in keys(a:options)
                                        if !has_key(err, key) || empty(err[key])
                                            let err[key] = a:options[key]
                                        endif
                                    endfor
                                endfor
                            
                                return a:errors
                            endfunction " }}}2
                            
    1              0.000001 function! s:_os_name() abort " {{{2
                                return g:_SYNTASTIC_UNAME
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim
Sourced 1 time
Total time:   0.000421
 Self time:   0.000421

count  total (s)   self (s)
    1              0.000005 if exists('g:loaded_syntastic_util_autoload') || !exists('g:loaded_syntastic_plugin')
                                finish
    1              0.000000 endif
    1              0.000002 let g:loaded_syntastic_util_autoload = 1
                            
    1              0.000006 let s:save_cpo = &cpo
    1              0.000005 set cpo&vim
                            
                            " Public functions {{{1
                            
    1              0.000002 function! syntastic#util#isRunningWindows() abort " {{{2
                                return has('win16') || has('win32') || has('win64')
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#util#DevNull() abort " {{{2
                                if syntastic#util#isRunningWindows()
                                    return 'NUL'
                                endif
                                return '/dev/null'
                            endfunction " }}}2
                            
                            " Get directory separator
    1              0.000001 function! syntastic#util#Slash() abort " {{{2
                                return (!exists('+shellslash') || &shellslash) ? '/' : '\'
                            endfunction " }}}2
                            
    1              0.000001 function! syntastic#util#CygwinPath(path) abort " {{{2
                                return substitute(syntastic#util#system('cygpath -m ' . syntastic#util#shescape(a:path)), "\n", '', 'g')
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#util#system(command) abort " {{{2
                                let old_shell = &shell
                                let old_lc_messages = $LC_MESSAGES
                                let old_lc_all = $LC_ALL
                            
                                let &shell = syntastic#util#var('shell')
                                let $LC_MESSAGES = 'C'
                                let $LC_ALL = ''
                            
                                let crashed = 0
                                let cmd_start = reltime()
                                try
                                    let out = system(a:command)
                                catch
                                    if v:exception =~# '\m^Vim\%((\a\+)\)\=:\%(E145\|E484\|E684\)'
                                        " XXX re-throwing unmodified v:exception triggers E608
                                        throw substitute(v:exception, '.*:\(E145\|E484\|E684\).*', '\1', '')
                                    endif
                            
                                    let crashed = 1
                                    call syntastic#log#error('exception running system(' . string(a:command) . '): ' . v:exception)
                                    if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
                                    endif
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '$PATH = ' . string($PATH))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
                                    let out = ''
                                endtry
                                let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
                            
                                let $LC_ALL = old_lc_all
                                let $LC_MESSAGES = old_lc_messages
                            
                                let &shell = old_shell
                            
                                if !crashed && exists('g:_SYNTASTIC_DEBUG_TRACE')
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
                                endif
                            
                                return out
                            endfunction " }}}2
                            
                            " Create a temporary directory
    1              0.000002 function! syntastic#util#tmpdir() abort " {{{2
                                let tempdir = ''
                            
                                if (has('unix') || has('mac')) && executable('mktemp') && !has('win32unix')
                                    " TODO: option "-t" to mktemp(1) is not portable
                                    let tmp = $TMPDIR !=# '' ? $TMPDIR : $TMP !=# '' ? $TMP : '/tmp'
                                    let out = split(syntastic#util#system('mktemp -q -d ' . tmp . '/vim-syntastic-' . s:_fuzz() . '-XXXXXXXX'), "\n")
                                    if v:shell_error == 0 && len(out) == 1
                                        let tempdir = out[0]
                                    endif
                                endif
                            
                                if tempdir ==# ''
                                    if has('win32') || has('win64')
                                        let tempdir = $TEMP . syntastic#util#Slash() . 'vim-syntastic-' . s:_fuzz()
                                    elseif has('win32unix')
                                        let tempdir = syntastic#util#CygwinPath('/tmp/vim-syntastic-'  . s:_fuzz())
                                    elseif $TMPDIR !=# ''
                                        let tempdir = $TMPDIR . '/vim-syntastic-' . s:_fuzz()
                                    else
                                        let tempdir = '/tmp/vim-syntastic-' . s:_fuzz()
                                    endif
                            
                                    try
                                        call mkdir(tempdir, 'p', 0700)
                                    catch /\m^Vim\%((\a\+)\)\=:E739/
                                        call syntastic#log#error(v:exception)
                                        let tempdir = '.'
                                    endtry
                                endif
                            
                                return tempdir
                            endfunction " }}}2
                            
                            " Recursively remove a directory
    1              0.000001 function! syntastic#util#rmrf(what) abort " {{{2
                                " try to make sure we don't delete directories we didn't create
                                if a:what !~? 'vim-syntastic-'
                                    return
                                endif
                            
                                if  getftype(a:what) ==# 'dir'
                                    call s:_delete(a:what, 'rf')
                                else
                                    silent! call delete(a:what)
                                endif
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#util#getbufvar(buf, name, ...) abort " {{{2
                                return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)
                            endfunction " }}}2
                            
                            " Search the first 5 lines of the file for a magic number and return a map
                            " containing the args and the executable
                            "
                            " e.g.
                            "
                            " #!/usr/bin/perl -f -bar
                            "
                            " returns
                            "
                            " {'exe': '/usr/bin/perl', 'args': ['-f', '-bar']}
    1              0.000001 function! syntastic#util#parseShebang(buf) abort " {{{2
                                for lnum in range(1, 5)
                                    let line = get(getbufline(a:buf, lnum), 0, '')
                                    if line =~# '^#!'
                                        let line = substitute(line, '\v^#!\s*(\S+/env(\s+-\S+)*\s+)?', '', '')
                                        let exe = matchstr(line, '\m^\S*\ze')
                                        let args = split(matchstr(line, '\m^\S*\zs.*'))
                                        return { 'exe': exe, 'args': args }
                                    endif
                                endfor
                            
                                return { 'exe': '', 'args': [] }
                            endfunction " }}}2
                            
                            " Get the value of a Vim variable.  Allow buffer variables to override global ones.
    1              0.000002 function! syntastic#util#bufRawVar(buf, name, ...) abort " {{{2
                                return s:_getbufvar(a:buf, a:name, get(g:, a:name, a:0 ? a:1 : ''))
                            endfunction "}}}2
                            
                            " Get the value of a syntastic variable.  Allow buffer variables to override global ones.
    1              0.000002 function! syntastic#util#bufVar(buf, name, ...) abort " {{{2
                                return call('syntastic#util#bufRawVar', [a:buf, 'syntastic_' . a:name] + a:000)
                            endfunction "}}}2
                            
                            " Get the value of a Vim variable.  Allow local variables to override global ones.
    1              0.000001 function! syntastic#util#rawVar(name, ...) abort " {{{2
                                return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))
                            endfunction " }}}2
                            
                            " Get the value of a syntastic variable.  Allow local variables to override global ones.
    1              0.000001 function! syntastic#util#var(name, ...) abort " {{{2
                                return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)
                            endfunction " }}}2
                            
                            " Parse a version string.  Return an array of version components.
    1              0.000002 function! syntastic#util#parseVersion(version, ...) abort " {{{2
                                return map(split(matchstr( a:version, a:0 ? a:1 : '\v^\D*\zs\d+(\.\d+)+\ze' ), '\m\.'), 'str2nr(v:val)')
                            endfunction " }}}2
                            
                            " Verify that the 'installed' version is at least the 'required' version.
                            "
                            " 'installed' and 'required' must be arrays. If they have different lengths,
                            " the "missing" elements will be assumed to be 0 for the purposes of checking.
                            "
                            " See http://semver.org for info about version numbers.
    1              0.000002 function! syntastic#util#versionIsAtLeast(installed, required) abort " {{{2
                                return syntastic#util#compareLexi(a:installed, a:required) >= 0
                            endfunction " }}}2
                            
                            " Almost lexicographic comparison of two lists of integers. :) If lists
                            " have different lengths, the "missing" elements are assumed to be 0.
    1              0.000001 function! syntastic#util#compareLexi(a, b) abort " {{{2
                                for idx in range(max([len(a:a), len(a:b)]))
                                    let a_element = str2nr(get(a:a, idx, 0))
                                    let b_element = str2nr(get(a:b, idx, 0))
                                    if a_element != b_element
                                        return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " still here, thus everything matched
                                return 0
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#util#screenWidth(str, tabstop) abort " {{{2
                                let chunks = split(a:str, "\t", 1)
                                let width = s:_width(chunks[-1])
                                for c in chunks[:-2]
                                    let cwidth = s:_width(c)
                                    let width += cwidth + a:tabstop - cwidth % a:tabstop
                                endfor
                                return width
                            endfunction " }}}2
                            
                            " Print as much of a:msg as possible without "Press Enter" prompt appearing
    1              0.000001 function! syntastic#util#wideMsg(msg) abort " {{{2
                                let old_ruler = &ruler
                                let old_showcmd = &showcmd
                            
                                "This is here because it is possible for some error messages to
                                "begin with \n which will cause a "press enter" prompt.
                                let msg = substitute(a:msg, "\n", '', 'g')
                            
                                "convert tabs to spaces so that the tabs count towards the window
                                "width as the proper amount of characters
                                let chunks = split(msg, "\t", 1)
                                let msg = join(map(chunks[:-2], 'v:val . repeat(" ", &tabstop - s:_width(v:val) % &tabstop)'), '') . chunks[-1]
                                let msg = strpart(msg, 0, &columns - 1)
                            
                                set noruler noshowcmd
                                call syntastic#util#redraw(0)
                            
                                echo msg
                            
                                let &ruler = old_ruler
                                let &showcmd = old_showcmd
                            endfunction " }}}2
                            
                            " Check whether a buffer is loaded, listed, and not hidden
    1              0.000001 function! syntastic#util#bufIsActive(buffer) abort " {{{2
                                " convert to number, or hell breaks loose
                                let buf = str2nr(a:buffer)
                            
                                if !bufloaded(buf) || !buflisted(buf)
                                    return 0
                                endif
                            
                                " get rid of hidden buffers
                                for tab in range(1, tabpagenr('$'))
                                    if index(tabpagebuflist(tab), buf) >= 0
                                        return 1
                                    endif
                                endfor
                            
                                return 0
                            endfunction " }}}2
                            
                            " Start in directory a:where and walk up the parent folders until it finds a
                            " file named a:what; return path to that file
    1              0.000002 function! syntastic#util#findFileInParent(what, where) abort " {{{2
                                let old_suffixesadd = &suffixesadd
                                let &suffixesadd = ''
                                let file = findfile(a:what, escape(a:where, ' ,') . ';')
                                let &suffixesadd = old_suffixesadd
                                return file
                            endfunction " }}}2
                            
                            " Start in directory a:where and walk up the parent folders until it finds a
                            " file matching a:what; return path to that file
    1              0.000002 function! syntastic#util#findGlobInParent(what, where) abort " {{{2
                                let here = fnamemodify(a:where, ':p')
                            
                                let root = syntastic#util#Slash()
                                if syntastic#util#isRunningWindows() && here[1] ==# ':'
                                    " The drive letter is an ever-green source of fun.  That's because
                                    " we don't care about running syntastic on Amiga these days. ;)
                                    let root = fnamemodify(root, ':p')
                                    let root = here[0] . root[1:]
                                endif
                            
                                let old = ''
                                while here !=# ''
                                    try
                                        " Vim 7.4.279 and later
                                        let p = globpath(here, a:what, 1, 1)
                                    catch /\m^Vim\%((\a\+)\)\=:E118/
                                        let p = split(globpath(here, a:what, 1), "\n")
                                    endtry
                            
                                    if !empty(p)
                                        return fnamemodify(p[0], ':p')
                                    elseif here ==? root || here ==? old
                                        break
                                    endif
                            
                                    let old = here
                            
                                    " we use ':h:h' rather than ':h' since ':p' adds a trailing '/'
                                    " if 'here' is a directory
                                    let here = fnamemodify(here, ':p:h:h')
                                endwhile
                            
                                return ''
                            endfunction " }}}2
                            
                            " Returns the buffer number of a filename
                            " @vimlint(EVL104, 1, l:old_shellslash)
    1              0.000002 function! syntastic#util#fname2buf(fname) abort " {{{2
                                if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
                                endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
                                let buf = -1
                                for md in [':~:.', ':~', ':p']
                                    try
                                        " Older versions of Vim can throw E94 here
                                        let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
                                    catch
                                        " catch everything
                                    endtry
                                    if buf != -1
                                        break
                                    endif
                                endfor
                                if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
                                endif
                            
                                if exists('+shellslash')
                                    let &shellslash = old_shellslash
                                endif
                            
                                return buf
                            endfunction " }}}2
                            " @vimlint(EVL104, 0, l:old_shellslash)
                            
                            " Returns unique elements in a list
    1              0.000001 function! syntastic#util#unique(list) abort " {{{2
                                let seen = {}
                                let uniques = []
                                for e in a:list
                                    let k = string(e)
                                    if !has_key(seen, k)
                                        let seen[k] = 1
                                        call add(uniques, e)
                                    endif
                                endfor
                                return uniques
                            endfunction " }}}2
                            
                            " A less noisy shellescape()
    1              0.000001 function! syntastic#util#shescape(string) abort " {{{2
                                return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)
                            endfunction " }}}2
                            
                            " A less noisy shellescape(expand())
    1              0.000001 function! syntastic#util#shexpand(string, ...) abort " {{{2
                                return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))
                            endfunction " }}}2
                            
                            " Escape arguments
    1              0.000001 function! syntastic#util#argsescape(opt) abort " {{{2
                                if type(a:opt) == type('') && a:opt !=# ''
                                    return [a:opt]
                                elseif type(a:opt) == type([])
                                    return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
                                endif
                            
                                return []
                            endfunction " }}}2
                            
                            " Decode XML entities
    1              0.000002 function! syntastic#util#decodeXMLEntities(string) abort " {{{2
                                let str = a:string
                                let str = substitute(str, '\m&lt;', '<', 'g')
                                let str = substitute(str, '\m&gt;', '>', 'g')
                                let str = substitute(str, '\m&quot;', '"', 'g')
                                let str = substitute(str, '\m&apos;', "'", 'g')
                                let str = substitute(str, '\m&amp;', '\&', 'g')
                                return str
                            endfunction " }}}2
                            
    1              0.000001 function! syntastic#util#redraw(full) abort " {{{2
                                if a:full
                                    redraw!
                                else
                                    redraw
                                endif
                            endfunction " }}}2
                            
    1              0.000001 function! syntastic#util#dictFilter(errors, filter) abort " {{{2
                                let rules = s:_translateFilter(a:filter)
                                " call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, "applying filter:", rules)
                                try
                                    call filter(a:errors, rules)
                                catch /\m^Vim\%((\a\+)\)\=:E/
                                    let msg = matchstr(v:exception, '\m^Vim\%((\a\+)\)\=:\zs.*')
                                    call syntastic#log#error('quiet_messages: ' . msg)
                                endtry
                            endfunction " }}}2
                            
                            " Return a [seconds, fractions] list of strings, representing the
                            " (hopefully high resolution) time since program start
    1              0.000001 function! syntastic#util#stamp() abort " {{{2
                                return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#util#setLastTick(buf) abort " {{{2
                                call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))
                            endfunction " }}}2
                            
                            " Add unique IDs to windows
    1              0.000001 function! syntastic#util#setWids() abort " {{{2
                                for tab in range(1, tabpagenr('$'))
                                    for win in range(1, tabpagewinnr(tab, '$'))
                                        if gettabwinvar(tab, win, 'syntastic_wid') ==# ''
                                            call settabwinvar(tab, win, 'syntastic_wid', s:_wid_base . s:_wid_pool)
                                            let s:_wid_pool += 1
                                        endif
                                    endfor
                                endfor
                            endfunction " }}}2
                            
    1              0.000001 function! syntastic#util#str2float(val) abort " {{{2
                                return s:_str2float(a:val)
                            endfunction " }}}2
                            
    1              0.000001 function! syntastic#util#float2str(val) abort " {{{2
                                return s:_float2str(a:val)
                            endfunction " }}}2
                            
                            " Crude printf()-like width formatter.  Handles wide characters.
    1              0.000001 function! syntastic#util#wformat(format, str) abort " {{{2
                                if a:format ==# ''
                                    return a:str
                                endif
                            
                             echomsg string(a:format) . ', ' . string(a:str)
                                let specs = matchlist(a:format, '\v^(-?)(0?)(%([1-9]\d*))?%(\.(\d+))?$')
                                if len(specs) < 5
                                    return a:str
                                endif
                            
                                let flushleft = specs[1] ==# '-'
                                let lpad = specs[2] ==# '0' ? '0' : ' '
                                let minlen = str2nr(specs[3])
                                let maxlen = str2nr(specs[4])
                                let out = substitute(a:str, "\t", ' ', 'g')
                            
                                if maxlen && s:_width(out) > maxlen
                                    let chars = filter(split(out, '\zs\ze', 1), 'v:val !=# ""')
                                    let out = ''
                            
                                    if flushleft
                                        for c in chars
                                            if s:_width(out . c) < maxlen
                                                let out .= c
                                            else
                                                let out .= &encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '>'
                                                break
                                            endif
                                        endfor
                                    else
                                        call reverse(chars)
                                        for c in chars
                                            if s:_width(c . out) < maxlen
                                                let out = c . out
                                            else
                                                let out = (&encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '<') . out
                                                break
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                if minlen && s:_width(out) < minlen
                                    if flushleft
                                        let out .= repeat(' ', minlen - s:_width(out))
                                    else
                                        let out = repeat(lpad, minlen - s:_width(out)) . out
                                    endif
                                endif
                            
                                return out
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000002 function! s:_translateFilter(filters) abort " {{{2
                                let conditions = []
                                for k in keys(a:filters)
                                    if type(a:filters[k]) == type([])
                                        call extend(conditions, map(copy(a:filters[k]), 's:_translateElement(k, v:val)'))
                                    else
                                        call add(conditions, s:_translateElement(k, a:filters[k]))
                                    endif
                                endfor
                            
                                if conditions == []
                                    let conditions = ['1']
                                endif
                                return len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
                            endfunction " }}}2
                            
    1              0.000002 function! s:_translateElement(key, term) abort " {{{2
                                let fkey = a:key
                                if fkey[0] ==# '!'
                                    let fkey = fkey[1:]
                                    let not = 1
                                else
                                    let not = 0
                                endif
                            
                                if fkey ==? 'level'
                                    let op = not ? ' ==? ' : ' !=? '
                                    let ret = 'v:val["type"]' . op . string(a:term[0])
                                elseif fkey ==? 'type'
                                    if a:term ==? 'style'
                                        let op = not ? ' ==? ' : ' !=? '
                                        let ret = 'get(v:val, "subtype", "")' . op . '"style"'
                                    else
                                        let op = not ? '!' : ''
                                        let ret = op . 'has_key(v:val, "subtype")'
                                    endif
                                elseif fkey ==? 'regex'
                                    let op = not ? ' =~? ' : ' !~? '
                                    let ret = 'v:val["text"]' . op . string(a:term)
                                elseif fkey ==? 'file' || fkey[:4] ==? 'file:'
                                    let op = not ? ' =~# ' : ' !~# '
                                    let ret = 'bufname(str2nr(v:val["bufnr"]))'
                                    let mod = fkey[4:]
                                    if mod !=# ''
                                        let ret = 'fnamemodify(' . ret . ', ' . string(mod) . ')'
                                    endif
                                    let ret .= op . string(a:term)
                                else
                                    call syntastic#log#warn('quiet_messages: ignoring invalid key ' . strtrans(string(fkey)))
                                    let ret = '1'
                                endif
                                return ret
                            endfunction " }}}2
                            
                            " strwidth() was added in Vim 7.3; if it doesn't exist, we use strlen()
                            " and hope for the best :)
    1              0.000006 let s:_width = function(exists('*strwidth') ? 'strwidth' : 'strlen')
    1              0.000001 lockvar s:_width
                            
                            " @vimlint(EVL103, 1, a:flags)
    1              0.000001 function! s:_delete_dumb(what, flags) abort " {{{2
                                if !exists('s:rmrf')
                                    let s:rmrf =
                                        \ has('unix') || has('mac') ? 'rm -rf' :
                                        \ has('win32') || has('win64') ? 'rmdir /S /Q' :
                                        \ has('win16') || has('win95') || has('dos16') || has('dos32') ? 'deltree /Y' : ''
                                endif
                            
                                if s:rmrf !=# ''
                                    silent! call syntastic#util#system(s:rmrf . ' ' . syntastic#util#shescape(a:what))
                                else
                                    call s:_rmrf(a:what)
                                endif
                            endfunction " }}}2
                            " @vimlint(EVL103, 0, a:flags)
                            
                            " delete(dir, 'rf') was added in Vim 7.4.1107, but it didn't become usable until 7.4.1128
    1              0.000005 let s:_delete = function(v:version > 704 || (v:version == 704 && has('patch1128')) ? 'delete' : 's:_delete_dumb')
    1              0.000001 lockvar s:_delete
                            
    1              0.000002 function! s:_rmrf(what) abort " {{{2
                                if !exists('s:rmdir')
                                    let s:rmdir = syntastic#util#shescape(get(g:, 'netrw_localrmdir', 'rmdir'))
                                endif
                            
                                if getftype(a:what) ==# 'dir'
                                    if filewritable(a:what) != 2
                                        return
                                    endif
                            
                                    try
                                        " Vim 7.4.279 and later
                                        let entries = globpath(a:what, '*', 1, 1)
                                    catch /\m^Vim\%((\a\+)\)\=:E118/
                                        let entries = split(globpath(a:what, '*', 1), "\n")
                                    endtry
                                    for f in entries
                                        call s:_rmrf(f)
                                    endfor
                                    silent! call syntastic#util#system(s:rmdir . ' ' . syntastic#util#shescape(a:what))
                                else
                                    silent! call delete(a:what)
                                endif
                            endfunction " }}}2
                            
    1              0.000005 let s:_str2float = function(exists('*str2float') ? 'str2float' : 'str2nr')
    1              0.000001 lockvar s:_str2float
                            
    1              0.000001 function! s:_float2str_smart(val) abort " {{{2
                                return printf('%.1f', a:val)
                            endfunction " }}}2
                            
    1              0.000001 function! s:_float2str_dumb(val) abort " {{{2
                                return a:val
                            endfunction " }}}2
                            
    1              0.000005 let s:_float2str = function(has('float') ? 's:_float2str_smart' : 's:_float2str_dumb')
    1              0.000001 lockvar s:_float2str
                            
    1              0.000002 function! s:_getbufvar_dumb(buf, name, ...) abort " {{{2
                                let ret = getbufvar(a:buf, a:name)
                                if a:0 && type(ret) == type('') && ret ==# ''
                                    unlet! ret
                                    let ret = a:1
                                endif
                                return ret
                            endfunction "}}}2
                            
    1              0.000006 let s:_getbufvar = function(v:version > 703 || (v:version == 703 && has('patch831')) ? 'getbufvar' : 's:_getbufvar_dumb')
    1              0.000001 lockvar s:_getbufvar
                            
    1              0.000002 function! s:_fuzz_dumb() abort " {{{2
                                return 'tmp'
                            endfunction " }}}2
                            
    1              0.000004 let s:_fuzz = function(exists('*getpid') ? 'getpid' : 's:_fuzz_dumb')
    1              0.000001 lockvar s:_fuzz
                            
                            " }}}1
                            
    1              0.000006 let s:_wid_base = 'syntastic_' . s:_fuzz() . '_' . reltimestr(g:_SYNTASTIC_START) . '_'
    1              0.000002 let s:_wid_pool = 0
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000001 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim
Sourced 1 time
Total time:   0.000170
 Self time:   0.000170

count  total (s)   self (s)
    1              0.000006 if exists('g:loaded_syntastic_log_autoload') || !exists('g:loaded_syntastic_plugin')
                                finish
    1              0.000000 endif
    1              0.000002 let g:loaded_syntastic_log_autoload = 1
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000006 set cpo&vim
                            
    1              0.000002 let s:one_time_notices_issued = []
                            
                            " Public functions {{{1
                            
    1              0.000002 function! syntastic#log#info(msg) abort " {{{2
                                echomsg 'syntastic: info: ' . a:msg
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#log#warn(msg) abort " {{{2
                                echohl WarningMsg
                                echomsg 'syntastic: warning: ' . a:msg
                                echohl None
                            endfunction " }}}2
                            
    1              0.000001 function! syntastic#log#error(msg) abort " {{{2
                                execute 'normal! \<Esc>'
                                echohl ErrorMsg
                                echomsg 'syntastic: error: ' . a:msg
                                echohl None
                            endfunction " }}}2
                            
    1              0.000001 function! syntastic#log#oneTimeWarn(msg) abort " {{{2
                                if index(s:one_time_notices_issued, a:msg) >= 0
                                    return
                                endif
                            
                                call add(s:one_time_notices_issued, a:msg)
                                call syntastic#log#warn(a:msg)
                            endfunction " }}}2
                            
                            " @vimlint(EVL102, 1, l:OLD_VAR)
    1              0.000002 function! syntastic#log#deprecationWarn(old, new, ...) abort " {{{2
                                if exists('g:syntastic_' . a:old) && !exists('g:syntastic_' . a:new)
                                    let msg = 'variable g:syntastic_' . a:old . ' is deprecated, please use '
                            
                                    if a:0
                                        let OLD_VAR = g:syntastic_{a:old}
                                        try
                                            let NEW_VAR = eval(a:1)
                                            let msg .= 'in its stead: let g:syntastic_' . a:new . ' = ' . string(NEW_VAR)
                                            let g:syntastic_{a:new} = NEW_VAR
                                        catch
                                            let msg .= 'g:syntastic_' . a:new . ' instead'
                                        endtry
                                    else
                                        let msg .= 'g:syntastic_' . a:new . ' instead'
                                        let g:syntastic_{a:new} = g:syntastic_{a:old}
                                    endif
                            
                                    call syntastic#log#oneTimeWarn(msg)
                                endif
                            endfunction " }}}2
                            " @vimlint(EVL102, 0, l:OLD_VAR)
                            
    1              0.000002 function! syntastic#log#debug(level, msg, ...) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' .
                                        \ strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ?
                                        \ filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#log#debugShowOptions(level, names) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#log#debugShowVariables(level, names) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)
                            endfunction " }}}2
                            
    1              0.000001 function! syntastic#log#debugDump(level) abort " {{{2
                                if !s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )
                            endfunction " }}}2
                            
    1              0.000002 function! syntastic#log#ndebug(level, title, messages) abort " {{{2
                                if s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                call syntastic#log#error(a:title)
                                if type(a:messages) == type([])
                                    for msg in a:messages
                                        echomsg msg
                                    endfor
                                else
                                    echomsg a:messages
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
    1              0.000002 function! s:_isDebugEnabled_smart(level) abort " {{{2
                                return and(g:syntastic_debug, a:level)
                            endfunction " }}}2
                            
    1              0.000002 function! s:_isDebugEnabled_dumb(level) abort " {{{2
                                " poor man's bit test for bit N, assuming a:level == 2**N
                                return (g:syntastic_debug / a:level) % 2
                            endfunction " }}}2
                            
    1              0.000007 let s:_isDebugEnabled = function(exists('*and') ? 's:_isDebugEnabled_smart' : 's:_isDebugEnabled_dumb')
    1              0.000001 lockvar s:_isDebugEnabled
                            
    1              0.000001 function! s:_logRedirect(on) abort " {{{2
                                if exists('g:syntastic_debug_file')
                                    if a:on
                                        try
                                            execute 'redir >> ' . fnameescape(expand(g:syntastic_debug_file, 1))
                                        catch /\m^Vim\%((\a\+)\)\=:/
                                            silent! redir END
                                            unlet g:syntastic_debug_file
                                        endtry
                                    else
                                        silent! redir END
                                    endif
                                endif
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Utilities {{{1
                            
    1              0.000001 function! s:_log_timestamp_smart() abort " {{{2
                                return printf('syntastic: %f: ', reltimefloat(reltime(g:_SYNTASTIC_START)))
                            endfunction " }}}2
                            
    1              0.000001 function! s:_log_timestamp_dumb() abort " {{{2
                                return 'syntastic: ' . split(reltimestr(reltime(g:_SYNTASTIC_START)))[0] . ': '
                            endfunction " }}}2
                            
    1              0.000009 let s:_log_timestamp = function(has('float') && exists('*reltimefloat') ? 's:_log_timestamp_smart' : 's:_log_timestamp_dumb')
    1              0.000001 lockvar s:_log_timestamp
                            
    1              0.000001 function! s:_format_variable(name) abort " {{{2
                                let vals = []
                                if exists('g:syntastic_' . a:name)
                                    call add(vals, 'g:syntastic_' . a:name . ' = ' . strtrans(string(g:syntastic_{a:name})))
                                endif
                                if exists('b:syntastic_' . a:name)
                                    call add(vals, 'b:syntastic_' . a:name . ' = ' . strtrans(string(b:syntastic_{a:name})))
                                endif
                            
                                return join(vals, ', ')
                            endfunction " }}}2
                            
    1              0.000001 function! s:_is_modified(name) abort " {{{2
                                if !exists('s:option_defaults')
                                    let s:option_defaults = {}
                                endif
                                if !has_key(s:option_defaults, a:name)
                                    let opt_save = eval('&' . a:name)
                                    execute 'set ' . a:name . '&'
                                    let s:option_defaults[a:name] = eval('&' . a:name)
                                    execute 'let &' . a:name . ' = ' . string(opt_save)
                                endif
                            
                                return s:option_defaults[a:name] !=# eval('&' . a:name)
                            endfunction " }}}2
                            
                            " }}}1
                            
    1              0.000005 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

SCRIPT  /home/david/.dotfiles/vim/.vim/plugged/syntastic/syntax_checkers/zsh/zsh.vim
Sourced 1 time
Total time:   0.000170
 Self time:   0.000054

count  total (s)   self (s)
                            "============================================================================
                            "File:        zsh.vim
                            "Description: Syntax checking plugin for syntastic
                            "Maintainer:  Martin Grenfell <martin.grenfell at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000004 if exists('g:loaded_syntastic_zsh_zsh_checker')
                                finish
    1              0.000000 endif
    1              0.000002 let g:loaded_syntastic_zsh_zsh_checker = 1
                            
    1              0.000005 let s:save_cpo = &cpo
    1              0.000008 set cpo&vim
                            
    1              0.000002 function! SyntaxCheckers_zsh_zsh_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args_after': '-n' })
                            
                                let errorformat = '%f:%l: %m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat})
                            endfunction
                            
    1   0.000122   0.000006 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'zsh',
                                \ 'name': 'zsh'})
                            
    1              0.000007 let &cpo = s:save_cpo
    1              0.000002 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

FUNCTION  <SNR>23__find_index()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/cursor.vim:116
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let max = len(a:messages) - 1
                                if max == 0
                                    return 0
                                endif
                                let min = 0
                            
                                " modified binary search: assign index 0 to columns to the left of the first error
                                while min < max - 1
                                    let mid = (min + max) / 2
                                    if a:column < a:messages[mid].scol
                                        let max = mid
                                    else
                                        let min = mid
                                    endif
                                endwhile
                            
                                return a:column < a:messages[max].scol ? min : max

FUNCTION  1()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/autoloclist.vim:10
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002     let newObj = copy(self)
    1              0.000000     return newObj

FUNCTION  2()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/autoloclist.vim:15
Called 1 time
Total time:   0.000079
 Self time:   0.000007

count  total (s)   self (s)
    1   0.000010   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: refresh')
    1   0.000068   0.000002     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  3()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/autoloclist.vim:20
Called 1 time
Total time:   0.000066
 Self time:   0.000041

count  total (s)   self (s)
    1   0.000007   0.000002     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'autoloclist: toggle')
    1   0.000011   0.000003     let auto_loc_list = syntastic#util#var('auto_loc_list')
    1   0.000003   0.000001     if !a:loclist.isEmpty()
                                    if auto_loc_list == 1 || auto_loc_list == 3
                                        call a:loclist.show()
                                    endif
    1              0.000000     else
    1              0.000003         if (auto_loc_list == 1 || auto_loc_list == 2) && !empty(get(w:, 'syntastic_loclist_set', []))
    1              0.000000             try
                                            " Vim 7.4.2200 or later
    1              0.000005                 let title = get(getloclist(0, { 'title': 1 }), 'title', ':SyntasticCheck ')
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            let title = ':SyntasticCheck '
    1              0.000000             endtry
                            
    1              0.000002             if strpart(title, 0, 16) ==# ':SyntasticCheck '
                                            " TODO: this will close the loc list window if one was opened
                                            " by something other than syntastic
    1   0.000013   0.000003                 call SyntasticLoclistHide()
                            
    1              0.000001                 try
                                                " Vim 7.4.2200 or later
    1              0.000003                     call setloclist(0, [], 'r', { 'title': '' })
                                            catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                                " do nothing
    1              0.000000                 endtry
    1              0.000002                 let w:syntastic_loclist_set = []
    1              0.000001             endif
    1              0.000000         endif
    1              0.000001     endif

FUNCTION  4()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/balloons.vim:14
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000002     let newObj = copy(self)
    1              0.000000     return newObj

FUNCTION  6()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/balloons.vim:24
Called 1 time
Total time:   0.000024
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000001     unlet! b:syntastic_private_balloons
    1   0.000016   0.000003     if self.enabled() && !a:loclist.isEmpty()
                                    let b:syntastic_private_balloons = a:loclist.balloons()
                                    if !empty(b:syntastic_private_balloons)
                                        set ballooneval balloonexpr=SyntasticBalloonsExprNotifier()
                                    endif
    1              0.000000     endif

FUNCTION  7()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/balloons.vim:36
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000004     if has('balloon_eval') && !empty(get(b:, 'syntastic_private_balloons', {}))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'balloons: reset')
                                    set noballooneval
    1              0.000001     endif
    1              0.000001     unlet! b:syntastic_private_balloons

FUNCTION  8()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:10
Called 1 time
Total time:   0.000064
 Self time:   0.000064

count  total (s)   self (s)
    1              0.000013     let newObj = copy(self)
                            
    1              0.000002     let newObj._filetype = a:args['filetype']
    1              0.000001     let newObj._name = a:args['name']
                            
    1              0.000000     if a:0
                                    " redirected checker
                                    let newObj._exec_default = get(a:args, 'exec', a:1['_exec_default'])
                            
                                    let filetype = a:1['_filetype']
                                    let name = a:1['_name']
                                    let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
                            
                                    if exists('g:syntastic_' . filetype . '_' . name . '_sort') && !exists('g:syntastic_' . newObj._filetype . '_' . newObj._name . '_sort')
                                        let g:syntastic_{newObj._filetype}_{newObj._name}_sort = g:syntastic_{filetype}_{name}_sort
                                    endif
                            
                                    if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
                                    elseif has_key(a:1, '_enable')
                                        let newObj._enable = a:1['_enable']
                                    endif
    1              0.000000     else
    1              0.000003         let newObj._exec_default = get(a:args, 'exec', newObj._name)
    1              0.000001         if newObj._exec_default ==# ''
                                        let newObj._exec_default = '<dummy>'
    1              0.000001         endif
    1              0.000002         let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
                            
    1              0.000002         if has_key(a:args, 'enable')
                                        let newObj._enable = a:args['enable']
    1              0.000000         endif
    1              0.000001     endif
                            
    1              0.000004     let newObj._locListFunc = function(prefix . 'GetLocList')
                            
    1              0.000002     if exists('*' . prefix . 'IsAvailable')
                                    let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
    1              0.000000     else
    1              0.000004         let newObj._isAvailableFunc = function('s:_isAvailableDefault')
    1              0.000000     endif
                            
    1              0.000002     if exists('*' . prefix . 'GetHighlightRegex')
                                    let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
    1              0.000000     endif
                            
    1              0.000001     return newObj

FUNCTION  9()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:60
Called 2 times
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    2              0.000002     return self._filetype

FUNCTION  syntastic#log#debug()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:63
Called 34 times
Total time:   0.000294
 Self time:   0.000185

count  total (s)   self (s)
   34   0.000242   0.000133     if !s:_isDebugEnabled(a:level)
   34              0.000032         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                if a:0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  syntastic#util#str2float()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:427
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return s:_str2float(a:val)

FUNCTION  syntastic#log#debugShowOptions()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:83
Called 2 times
Total time:   0.000028
 Self time:   0.000019

count  total (s)   self (s)
    2   0.000024   0.000015     if !s:_isDebugEnabled(a:level)
    2              0.000003         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type('') ? [a:names] : a:names)
                                let add_shell = index(vlist, 'shell') >= 0 && &shell !=# syntastic#util#var('shell')
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val))) . (s:_is_modified(v:val) ? ' (!)' : '')")
                                    if add_shell
                                        call add(vlist, 'u:shell = ' . strtrans(string(syntastic#util#var('shell'))) . ' (!)')
                                    endif
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  5()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/balloons.vim:19
Called 2 times
Total time:   0.000023
 Self time:   0.000007

count  total (s)   self (s)
    2   0.000022   0.000006     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  syntastic#util#tmpdir()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:78
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let tempdir = ''
                            
                                if (has('unix') || has('mac')) && executable('mktemp') && !has('win32unix')
                                    " TODO: option "-t" to mktemp(1) is not portable
                                    let tmp = $TMPDIR !=# '' ? $TMPDIR : $TMP !=# '' ? $TMP : '/tmp'
                                    let out = split(syntastic#util#system('mktemp -q -d ' . tmp . '/vim-syntastic-' . s:_fuzz() . '-XXXXXXXX'), "\n")
                                    if v:shell_error == 0 && len(out) == 1
                                        let tempdir = out[0]
                                    endif
                                endif
                            
                                if tempdir ==# ''
                                    if has('win32') || has('win64')
                                        let tempdir = $TEMP . syntastic#util#Slash() . 'vim-syntastic-' . s:_fuzz()
                                    elseif has('win32unix')
                                        let tempdir = syntastic#util#CygwinPath('/tmp/vim-syntastic-'  . s:_fuzz())
                                    elseif $TMPDIR !=# ''
                                        let tempdir = $TMPDIR . '/vim-syntastic-' . s:_fuzz()
                                    else
                                        let tempdir = '/tmp/vim-syntastic-' . s:_fuzz()
                                    endif
                            
                                    try
                                        call mkdir(tempdir, 'p', 0700)
                                    catch /\m^Vim\%((\a\+)\)\=:E739/
                                        call syntastic#log#error(v:exception)
                                        let tempdir = '.'
                                    endtry
                                endif
                            
                                return tempdir

FUNCTION  syntastic#log#error()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:23
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                execute 'normal! \<Esc>'
                                echohl ErrorMsg
                                echomsg 'syntastic: error: ' . a:msg
                                echohl None

FUNCTION  <SNR>120__is_modified()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:203
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('s:option_defaults')
                                    let s:option_defaults = {}
                                endif
                                if !has_key(s:option_defaults, a:name)
                                    let opt_save = eval('&' . a:name)
                                    execute 'set ' . a:name . '&'
                                    let s:option_defaults[a:name] = eval('&' . a:name)
                                    execute 'let &' . a:name . ' = ' . string(opt_save)
                                endif
                            
                                return s:option_defaults[a:name] !=# eval('&' . a:name)

FUNCTION  syntastic#util#shescape()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:355
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000019     return a:string =~# '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  SyntaxCheckers_zsh_zsh_GetLocList()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/syntax_checkers/zsh/zsh.vim:21
Called 1 time
Total time:   0.004616
 Self time:   0.000021

count  total (s)   self (s)
    1   0.000284   0.000006     let makeprg = self.makeprgBuild({ 'args_after': '-n' })
                            
    1              0.000001     let errorformat = '%f:%l: %m'
                            
    1   0.004329   0.000012     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat})

FUNCTION  <SNR>31__delete_dumb()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:554
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('s:rmrf')
                                    let s:rmrf = has('unix') || has('mac') ? 'rm -rf' : has('win32') || has('win64') ? 'rmdir /S /Q' : has('win16') || has('win95') || has('dos16') || has('dos32') ? 'deltree /Y' : ''
                                endif
                            
                                if s:rmrf !=# ''
                                    silent! call syntastic#util#system(s:rmrf . ' ' . syntastic#util#shescape(a:what))
                                else
                                    call s:_rmrf(a:what)
                                endif

FUNCTION  <SNR>30_CompleteFiletypes()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:217
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return join(s:registry.getKnownFiletypes(), "\n")

FUNCTION  <SNR>120__format_variable()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:191
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let vals = []
                                if exists('g:syntastic_' . a:name)
                                    call add(vals, 'g:syntastic_' . a:name . ' = ' . strtrans(string(g:syntastic_{a:name})))
                                endif
                                if exists('b:syntastic_' . a:name)
                                    call add(vals, 'b:syntastic_' . a:name . ' = ' . strtrans(string(b:syntastic_{a:name})))
                                endif
                            
                                return join(vals, ', ')

FUNCTION  SyntasticErrors()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:251
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call g:SyntasticLoclist.current().show()

FUNCTION  syntastic#util#rmrf()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:113
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " try to make sure we don't delete directories we didn't create
                                if a:what !~? 'vim-syntastic-'
                                    return
                                endif
                            
                                if  getftype(a:what) ==# 'dir'
                                    call s:_delete(a:what, 'rf')
                                else
                                    silent! call delete(a:what)
                                endif

FUNCTION  syntastic#util#decodeXMLEntities()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:376
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let str = a:string
                                let str = substitute(str, '\m&lt;', '<', 'g')
                                let str = substitute(str, '\m&gt;', '>', 'g')
                                let str = substitute(str, '\m&quot;', '"', 'g')
                                let str = substitute(str, '\m&apos;', "'", 'g')
                                let str = substitute(str, '\m&amp;', '\&', 'g')
                                return str

FUNCTION  <SNR>30__is_quitting()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:715
Called 3 times
Total time:   0.000102
 Self time:   0.000102

count  total (s)   self (s)
    3              0.000007     let quitting = 0
    3              0.000014     if exists('w:syntastic_wid')
    1              0.000021         let key = a:buf . '_' . getbufvar(a:buf, 'changetick') . '_' . w:syntastic_wid
    1              0.000010         let idx = index(s:_quit_pre, key)
    1              0.000004         if idx >= 0
    1              0.000009             call remove(s:_quit_pre, idx)
    1              0.000004             let quitting = 1
    1              0.000002         endif
    3              0.000002     endif
                            
    3              0.000005     return quitting

FUNCTION  syntastic#util#versionIsAtLeast()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:185
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return syntastic#util#compareLexi(a:installed, a:required) >= 0

FUNCTION  syntastic#util#Slash()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:23
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return (!exists('+shellslash') || &shellslash) ? '/' : '\'

FUNCTION  SyntasticSetLoclist()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:267
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call g:SyntasticLoclist.current().setloclist(0)

FUNCTION  SyntasticRefreshCursor()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/cursor.vim:43
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('b:syntastic_private_messages') || empty(b:syntastic_private_messages)
                                    " file not checked
                                    return
                                endif
                            
                                if !exists('b:syntastic_private_line')
                                    let b:syntastic_private_line = -1
                                endif
                                let l = line('.')
                                let current_messages = get(b:syntastic_private_messages, l, {})
                            
                                if !exists('b:syntastic_cursor_columns')
                                    let b:syntastic_cursor_columns = g:syntastic_cursor_columns
                                endif
                            
                                if b:syntastic_cursor_columns
                                    let c = virtcol('.')
                                    if !exists('b:syntastic_private_idx')
                                        let b:syntastic_private_idx = -1
                                    endif
                            
                                    if s:_is_same_index(l, b:syntastic_private_line, c, b:syntastic_private_idx, current_messages)
                                        return
                                    else
                                        let b:syntastic_private_line = l
                                    endif
                            
                                    if !empty(current_messages)
                                        let b:syntastic_private_idx = s:_find_index(c, current_messages)
                                        call syntastic#util#wideMsg(current_messages[b:syntastic_private_idx].text)
                                    else
                                        let b:syntastic_private_idx = -1
                                        echo
                                    endif
                                else
                                    if l == b:syntastic_private_line
                                        return
                                    endif
                                    let b:syntastic_private_line = l
                            
                                    if !empty(current_messages)
                                        call syntastic#util#wideMsg(current_messages[0].text)
                                    else
                                        echo
                                    endif
                                endif

FUNCTION  <SNR>30__explain_skip()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:743
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let buf = bufnr('')
                                if empty(a:filetypes) && s:_skip_file(buf)
                                    let why = []
                                    let fname = bufname(buf)
                                    let bt = getbufvar(buf, '&buftype')
                            
                                    if s:_is_quitting(buf)
                                        call add(why, 'quitting buffer')
                                    endif
                                    if getbufvar(buf, 'syntastic_skip_checks')
                                        call add(why, 'b:syntastic_skip_checks set')
                                    endif
                                    if bt !=# ''
                                        call add(why, 'buftype = ' . string(&buftype))
                                    endif
                                    if !filereadable(fname)
                                        call add(why, 'file not readable / not local')
                                    endif
                                    if getwinvar(0, '&diff')
                                        call add(why, 'diff mode')
                                    endif
                                    if getwinvar(0, '&previewwindow')
                                        call add(why, 'preview window')
                                    endif
                                    if s:_ignore_file(fname)
                                        call add(why, 'filename matching g:syntastic_ignore_files')
                                    endif
                                    if fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
                                        call add(why, 'extension matching g:syntastic_ignore_extensions')
                                    endif
                            
                                    echomsg 'The current file will not be checked (' . join(why, ', ') . ')'
                                endif

FUNCTION  12()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:78
Called 1 time
Total time:   0.000030
 Self time:   0.000014

count  total (s)   self (s)
    1              0.000001     if a:0
                                    let self._exec = a:1
    1              0.000000     else
    1              0.000002         let suffix = self._name . '_exec'
    1   0.000026   0.000010         let self._exec = expand( syntastic#util#var(self._filetype . '_' . suffix, syntastic#util#var(suffix, self._exec_default)), 1 )
    1              0.000000     endif

FUNCTION  13()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:89
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return self._exec

FUNCTION  14()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:93
Called 1 time
Total time:   0.000013
 Self time:   0.000003

count  total (s)   self (s)
    1   0.000013   0.000003     return syntastic#util#shescape(self._exec)

FUNCTION  15()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:97
Called 1 time
Total time:   0.004778
 Self time:   0.000077

count  total (s)   self (s)
    1              0.000002     let checker_start = reltime()
    1   0.000004   0.000002     let name = self.getCName()
                            
    1              0.000002     if has_key(self, '_enable')
                                    let status = syntastic#util#var(self._enable, -1)
                                    if type(status) != type(0)
                                        call syntastic#log#error('checker ' . name . ': invalid value ' . strtrans(string(status)) . ' for g:syntastic_' . self._enable . '; try 0 or 1 instead')
                                        return []
                                    endif
                                    if status < 0
                                        call syntastic#log#error('checker ' . name . ': checks disabled for security reasons; ' . 'set g:syntastic_' . self._enable . ' to 1 to override')
                                    endif
                                    if status <= 0
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' enabled but not forced')
                                        return []
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' forced')
                                    endif
    1              0.000000     endif
                            
    1              0.000000     try
    1   0.004623   0.000007         let list = self._locListFunc()
    1              0.000002         if self._exec !=# ''
    1   0.000011   0.000005             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
    1              0.000000         endif
                                catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    if self._exec !=# ''
                                        call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                    else
                                        call syntastic#log#error('checker ' . name . ' aborted')
                                    endif
    1              0.000000     endtry
    1   0.000015   0.000005     call self._populateHighlightRegexes(list)
    1   0.000009   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, name . ' raw:', list)
    1   0.000059   0.000002     call self._quietMessages(list)
    1   0.000019   0.000014     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getLocList: checker ' . name . ' run in ' . split(reltimestr(reltime(checker_start)))[0] . 's')
    1              0.000001     return list

FUNCTION  16()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:141
Called 1 time
Total time:   0.004827
 Self time:   0.000012

count  total (s)   self (s)
    1   0.004827   0.000012     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  17()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:145
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._version')
                                    let command = a:0 ? a:1 : self.getExecEscaped() . ' --version'
                                    let version_output = syntastic#util#system(command)
                                    call self.log('getVersion: ' . string(command) . ': ' . string(split(version_output, "\n", 1)) . (v:shell_error ? ' (exit code ' . v:shell_error . ')' : '') )
                                    let parsed_ver = syntastic#util#parseVersion(version_output)
                                    if len(parsed_ver)
                                        call self.setVersion(parsed_ver)
                                    else
                                        call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', split(version_output, "\n", 1))
                                        call syntastic#log#error("checker " . self.getCName() . ": can't parse version string (abnormal termination?)")
                                    endif
                                endif
                                return get(self, '_version', [])

FUNCTION  18()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:163
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if len(a:version)
                                    let self._version = copy(a:version)
                                    call self.log(self.getExec() . ' version =', a:version)
                                endif

FUNCTION  19()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:170
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let leader = self.getCName() . ': '
                                if a:0
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg, a:1)
                                else
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, leader . a:msg)
                                endif

FUNCTION  syntastic#util#stamp()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:407
Called 3 times
Total time:   0.000033
 Self time:   0.000033

count  total (s)   self (s)
    3              0.000033     return split( split(reltimestr(reltime(g:_SYNTASTIC_START)))[0], '\.' )

FUNCTION  <SNR>31__fuzz_dumb()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:625
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return 'tmp'

FUNCTION  20()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:179
Called 1 time
Total time:   0.000278
 Self time:   0.000031

count  total (s)   self (s)
    1              0.000002     let basename = self._filetype . '_' . self._name . '_'
                            
    1              0.000001     let parts = []
    1   0.000067   0.000006     call extend(parts, self._getOpt(a:opts, basename, 'exe', self.getExecEscaped()))
    1   0.000047   0.000004     call extend(parts, self._getOpt(a:opts, basename, 'args', ''))
    1   0.000062   0.000007     call extend(parts, self._getOpt(a:opts, basename, 'fname', syntastic#util#shexpand('%')))
    1   0.000048   0.000004     call extend(parts, self._getOpt(a:opts, basename, 'post_args', ''))
    1   0.000048   0.000004     call extend(parts, self._getOpt(a:opts, basename, 'tail', ''))
                            
    1              0.000002     return join(parts)

FUNCTION  21()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:192
Called 1 time
Total time:   0.000058
 Self time:   0.000014

count  total (s)   self (s)
    1   0.000033   0.000003     call self.syncExec()
                            
    1              0.000002     if !has_key(self, '_available')
    1              0.000001         let self._available = {}
    1              0.000001     endif
    1              0.000001     if !has_key(self._available, self._exec)
    1   0.000017   0.000003         let self._available[self._exec] = self._isAvailableFunc()
    1              0.000001     endif
                            
    1              0.000001     return self._available[self._exec]

FUNCTION  22()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:205
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return has_key(self, '_enable') && syntastic#util#var(self._enable, -1) <= 0

FUNCTION  23()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:209
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return syntastic#util#var(self._filetype . '_' . self._name . '_sort', 0)

FUNCTION  24()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:215
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('g:syntastic_' . self._filetype . '_' . self._name . '_sort')
                                    let g:syntastic_{self._filetype}_{self._name}_sort = a:val
                                endif

FUNCTION  25()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:225
Called 1 time
Total time:   0.000057
 Self time:   0.000035

count  total (s)   self (s)
                                " wildcard quiet_messages
    1   0.000015   0.000005     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
    1              0.000002     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
    1              0.000000     endif
                            
                                " per checker quiet_messages
    1              0.000002     let name = self._filetype . '_' . self._name
    1              0.000001     try
    1   0.000013   0.000006         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
                                catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
    1              0.000001     endtry
                            
    1   0.000009   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'quiet_messages filter:', quiet_filters)
                            
    1              0.000001     if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'filtered by quiet_messages:', a:errors)
    1              0.000000     endif

FUNCTION  26()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:250
Called 1 time
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    1              0.000003     if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term !=# ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
    1              0.000000     endif

FUNCTION  27()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:263
Called 5 times
Total time:   0.000220
 Self time:   0.000086

count  total (s)   self (s)
    5              0.000005     let ret = []
    5   0.000060   0.000022     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_before', '')) )
    5   0.000099   0.000032     call extend( ret, syntastic#util#argsescape(syntastic#util#var( a:basename . a:name, get(a:opts, a:name, a:default) )) )
    5   0.000051   0.000022     call extend( ret, syntastic#util#argsescape(get(a:opts, a:name . '_after', '')) )
                            
    5              0.000003     return ret

FUNCTION  28()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/cursor.vim:10
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003     let newObj = copy(self)
    1              0.000001     return newObj

FUNCTION  29()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/cursor.vim:15
Called 2 times
Total time:   0.000019
 Self time:   0.000006

count  total (s)   self (s)
    2   0.000019   0.000006     return syntastic#util#var('echo_current_error')

FUNCTION  syntastic#util#findFileInParent()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:258
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let old_suffixesadd = &suffixesadd
                                let &suffixesadd = ''
                                let file = findfile(a:what, escape(a:where, ' ,') . ';')
                                let &suffixesadd = old_suffixesadd
                                return file

FUNCTION  syntastic#util#parseShebang()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:140
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                for lnum in range(1, 5)
                                    let line = get(getbufline(a:buf, lnum), 0, '')
                                    if line =~# '^#!'
                                        let line = substitute(line, '\v^#!\s*(\S+/env(\s+-\S+)*\s+)?', '', '')
                                        let exe = matchstr(line, '\m^\S*\ze')
                                        let args = split(matchstr(line, '\m^\S*\zs.*'))
                                        return { 'exe': exe, 'args': args }
                                    endif
                                endfor
                            
                                return { 'exe': '', 'args': [] }

FUNCTION  <SNR>31__float2str_dumb()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:606
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return a:val

FUNCTION  30()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/cursor.vim:19
Called 1 time
Total time:   0.000023
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000014   0.000003     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: refresh')
                                    let b:syntastic_private_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_private_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
    1              0.000001     endif

FUNCTION  31()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/cursor.vim:31
Called 1 time
Total time:   0.000016
 Self time:   0.000011

count  total (s)   self (s)
    1   0.000008   0.000003     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'cursor: reset')
    1              0.000003     autocmd! syntastic CursorMoved
    1              0.000001     unlet! b:syntastic_private_messages
    1              0.000001     let b:syntastic_private_line = -1

FUNCTION  32()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim:16
Called 1 time
Total time:   0.000035
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000003     let newObj = copy(self)
                            
    1              0.000001     if !s:setup_done
    1   0.000027   0.000003         call self._setup()
    1              0.000001         let s:setup_done = 1
    1              0.000001         lockvar s:setup_done
    1              0.000001     endif
                            
    1              0.000001     return newObj

FUNCTION  33()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim:28
Called 2 times
Total time:   0.000020
 Self time:   0.000006

count  total (s)   self (s)
    2   0.000020   0.000006     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  34()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim:33
Called 1 time
Total time:   0.000060
 Self time:   0.000037

count  total (s)   self (s)
    1   0.000012   0.000003     if self.enabled()
    1   0.000009   0.000003         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: refresh')
    1   0.000008   0.000002         call self._reset()
    1              0.000002         let buf = bufnr('')
    1   0.000006   0.000004         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    1              0.000001         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
    1              0.000001         endfor
    1              0.000000     endif

FUNCTION  35()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim:64
Called 1 time
Total time:   0.000020
 Self time:   0.000007

count  total (s)   self (s)
    1              0.000001     if s:has_highlighting
    1   0.000009   0.000003         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'highlighting: reset')
    1   0.000010   0.000003         call self._reset()
    1              0.000000     endif

FUNCTION  36()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim:77
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000001     if s:has_highlighting
    1              0.000004         if !hlexists('SyntasticError')
    1              0.000004             highlight link SyntasticError SpellBad
    1              0.000001         endif
    1              0.000002         if !hlexists('SyntasticWarning')
    1              0.000002             highlight link SyntasticWarning SpellCap
    1              0.000001         endif
    1              0.000001         if !hlexists('SyntasticStyleError')
    1              0.000002             highlight link SyntasticStyleError SyntasticError
    1              0.000001         endif
    1              0.000001         if !hlexists('SyntasticStyleWarning')
    1              0.000002             highlight link SyntasticStyleWarning SyntasticWarning
    1              0.000001         endif
    1              0.000000     endif

FUNCTION  37()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/highlighting.vim:94
Called 2 times
Total time:   0.000013
 Self time:   0.000013

count  total (s)   self (s)
    2              0.000004     for match in getmatches()
                                    if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
    2              0.000002     endfor

FUNCTION  38()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:10
Called 5 times
Total time:   0.000155
 Self time:   0.000155

count  total (s)   self (s)
    5              0.000059     let newObj = copy(self)
                            
    5              0.000020     let llist = filter(copy(a:rawLoclist), 'v:val["valid"]')
                            
    5              0.000007     for e in llist
                                    if get(e, 'type', '') ==# ''
                                        let e['type'] = 'E'
                                    endif
    5              0.000004     endfor
                            
    5              0.000009     let newObj._rawLoclist = llist
    5              0.000005     let newObj._name = ''
    5              0.000010     let newObj._owner = bufnr('')
    5              0.000005     let newObj._sorted = 0
    5              0.000008     let newObj._columns = g:syntastic_cursor_columns
                            
    5              0.000004     return newObj

FUNCTION  39()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:30
Called 157 times
Total time:   0.011001
 Self time:   0.008393

count  total (s)   self (s)
  157              0.001484     let buf = a:0 ? a:1 : bufnr('')
  157   0.004963   0.002450     let loclist = syntastic#util#getbufvar(buf, 'syntastic_loclist', {})
  157              0.001760     if type(loclist) != type({}) || empty(loclist)
    3              0.000004         unlet! loclist
    3   0.000107   0.000012         let loclist = g:SyntasticLoclist.New([])
  157              0.000302     endif
  157              0.000448     return loclist

FUNCTION  syntastic#util#float2str()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:431
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return s:_float2str(a:val)

FUNCTION  <SNR>30_BufWritePostHook()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:312
Called 1 time
Total time:   0.000804
 Self time:   0.000091

count  total (s)   self (s)
    1   0.000268   0.000030     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000073   0.000039     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWritePost, buffer ' . buf . ' = ' . string(a:fname))
    1   0.000458   0.000017     call s:UpdateErrors(buf, 1, [])

FUNCTION  <SNR>25__set_screen_column()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:360
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !has_key(a:item, 'scol')
                                    let col = get(a:item, 'col', 0)
                                    if col != 0 && get(a:item, 'vcol', 0) == 0
                                        let buf = str2nr(a:item['bufnr'])
                                        try
                                            let line = getbufline(buf, a:item['lnum'])[0]
                                        catch  /\m^Vim\%((\a\+)\)\=:E684/
                                            let line = ''
                                        endtry
                                        let a:item['scol'] = syntastic#util#screenWidth(strpart(line, 0, col), getbufvar(buf, '&tabstop'))
                                    else
                                        let a:item['scol'] = col
                                    endif
                                endif

FUNCTION  40()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:40
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call extend(self._rawLoclist, a:other.copyRaw())

FUNCTION  41()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:44
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !self._sorted
                                    for e in self._rawLoclist
                                        call s:_set_screen_column(e)
                                    endfor
                            
                                    call sort(self._rawLoclist, self._columns ? 's:_compare_error_items_by_columns' : 's:_compare_error_items_by_lines')
                            
                                    let self._sorted = 1
                                endif

FUNCTION  42()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:56
Called 6 times
Total time:   0.000010
 Self time:   0.000010

count  total (s)   self (s)
    6              0.000010     return empty(self._rawLoclist)

FUNCTION  43()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:60
Called 2 times
Total time:   0.000061
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000004     if !exists('self._stamp')
                                    let self._stamp = []
                                    return 0
    2              0.000001     endif
    2   0.000053   0.000007     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  44()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:68
Called 1 time
Total time:   0.000002
 Self time:   0.000002

count  total (s)   self (s)
    1              0.000002     return copy(self._rawLoclist)

FUNCTION  45()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:72
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return self._rawLoclist

FUNCTION  46()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:76
Called 2 times
Total time:   0.000056
 Self time:   0.000014

count  total (s)   self (s)
    2   0.000056   0.000014     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  47()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:80
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return self._columns

FUNCTION  48()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:84
Called 155 times
Total time:   0.024862
 Self time:   0.024862

count  total (s)   self (s)
  155              0.001227     if !exists('self._stl_format')
    3              0.000003         let self._stl_format = ''
  155              0.000252     endif
  155              0.000786     if !exists('self._stl_flag')
    3              0.000003         let self._stl_flag = ''
  155              0.000241     endif
                            
  155              0.000825     if g:syntastic_stl_format !=# self._stl_format
  152              0.000925         let self._stl_format = g:syntastic_stl_format
                            
  152              0.000759         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
  152              0.000329         else
  152              0.000572             let self._stl_flag = ''
  152              0.000293         endif
  155              0.000255     endif
                            
  155              0.000535     return self._stl_flag

FUNCTION  49()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:139
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let max_issues = len(self._rawLoclist)
                                if a:0 && a:1 < max_issues
                                    let max_issues = a:1
                                endif
                            
                                for idx in range(max_issues)
                                    if get(self._rawLoclist[idx], 'type', '') ==? 'E'
                                        return idx + 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>30_CompleteCheckerName()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:193
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let names = []
                            
                                let sep_idx = stridx(a:argLead, '/')
                                if sep_idx >= 1
                                    let ft = a:argLead[: sep_idx-1]
                                    call extend(names, map( s:registry.getNamesOfAvailableCheckers(ft), 'ft . "/" . v:val' ))
                                else
                                    for ft in s:registry.resolveFiletypes(&filetype)
                                        call extend(names, s:registry.getNamesOfAvailableCheckers(ft))
                                    endfor
                                    call extend(names, map( copy(s:registry.getKnownFiletypes()), 'v:val . "/"' ))
                                endif
                            
                                return join(names, "\n")

FUNCTION  syntastic#util#redraw()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:386
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:full
                                    redraw!
                                else
                                    redraw
                                endif

FUNCTION  syntastic#log#oneTimeWarn()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:30
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if index(s:one_time_notices_issued, a:msg) >= 0
                                    return
                                endif
                            
                                call add(s:one_time_notices_issued, a:msg)
                                call syntastic#log#warn(a:msg)

FUNCTION  50()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:154
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return len(self._name)

FUNCTION  51()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:158
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let self._name = a:name

FUNCTION  52()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:162
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return self._owner

FUNCTION  53()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:166
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  54()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:170
Called 1 time
Total time:   0.000057
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000015   0.000003     let self._stamp = syntastic#util#stamp()
    2   0.000033   0.000004     for buf in self.getBuffers()
    1              0.000005         call setbufvar(buf, 'syntastic_loclist', self)
    2              0.000001     endfor

FUNCTION  55()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:177
Called 1 time
Total time:   0.000038
 Self time:   0.000011

count  total (s)   self (s)
    2   0.000031   0.000004     for buf in self.getBuffers()
    1              0.000003         call setbufvar(buf, 'syntastic_loclist', {})
    2              0.000001     endfor

FUNCTION  56()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:183
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                for e in self._rawLoclist
                                    let e['text'] .= ' [' . a:tag . ']'
                                endfor

FUNCTION  57()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:189
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._cachedBalloons')
                                    let sep = has('balloon_multiline') ? "\n" : ' | '
                            
                                    let self._cachedBalloons = {}
                                    for e in self._rawLoclist
                                        let buf = e['bufnr']
                            
                                        if !has_key(self._cachedBalloons, buf)
                                            let self._cachedBalloons[buf] = {}
                                        endif
                            
                                        if has_key(self._cachedBalloons[buf], e['lnum'])
                                            let self._cachedBalloons[buf][e['lnum']] .= sep . e['text']
                                        else
                                            let self._cachedBalloons[buf][e['lnum']] = e['text']
                                        endif
                                    endfor
                                endif
                            
                                return get(self._cachedBalloons, bufnr(''), {})

FUNCTION  syntastic#util#rawVar()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:165
Called 25 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
   25              0.000105     return get(b:, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  59()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:219
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._cachedWarnings')
                                    let self._cachedWarnings = self.filter({'type': 'W'})
                                endif
                                return self._cachedWarnings

FUNCTION  11()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:68
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003     return self._filetype . '/' . self._name

FUNCTION  <SNR>120__logRedirect()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:161
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if exists('g:syntastic_debug_file')
                                    if a:on
                                        try
                                            execute 'redir >> ' . fnameescape(expand(g:syntastic_debug_file, 1))
                                        catch /\m^Vim\%((\a\+)\)\=:/
                                            silent! redir END
                                            unlet g:syntastic_debug_file
                                        endtry
                                    else
                                        silent! redir END
                                    endif
                                endif

FUNCTION  60()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:228
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return !self.isEmpty()

FUNCTION  61()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:233
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._cachedMessages')
                                    let self._cachedMessages = {}
                            
                                    let errors = self.errors() + self.warnings()
                                    for e in errors
                                        let b = e['bufnr']
                                        let l = e['lnum']
                            
                                        if !has_key(self._cachedMessages, b)
                                            let self._cachedMessages[b] = {}
                                        endif
                            
                                        if !has_key(self._cachedMessages[b], l)
                                            let self._cachedMessages[b][l] = [e]
                                        elseif self._columns
                                            call add(self._cachedMessages[b][l], e)
                                        endif
                                    endfor
                            
                                    if self._columns
                                        if !self._sorted
                                            for b in keys(self._cachedMessages)
                                                for l in keys(self._cachedMessages[b])
                                                    if len(self._cachedMessages[b][l]) > 1
                                                        for e in self._cachedMessages[b][l]
                                                            call s:_set_screen_column(e)
                                                        endfor
                                                        call sort(self._cachedMessages[b][l], 's:_compare_error_items_by_columns')
                                                    endif
                                                endfor
                                            endfor
                                        endif
                            
                                        for b in keys(self._cachedMessages)
                                            for l in keys(self._cachedMessages[b])
                                                call s:_remove_shadowed_items(self._cachedMessages[b][l])
                                            endfor
                                        endfor
                                    endif
                                endif
                            
                                return get(self._cachedMessages, a:buf, {})

FUNCTION  62()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:285
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let conditions = values(map(copy(a:filters), 's:_translate(v:key, v:val)'))
                                let filter = len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')
                                return filter(copy(self._rawLoclist), filter)

FUNCTION  63()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:292
Called 1 time
Total time:   0.000043
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000002     if !exists('w:syntastic_loclist_set')
    1              0.000002         let w:syntastic_loclist_set = []
    1              0.000001     endif
    1              0.000003     if a:new || empty(w:syntastic_loclist_set) || w:syntastic_loclist_set != [self._owner, getbufvar(self._owner, 'changedtick')]
    1              0.000003         let replace = !a:new && g:syntastic_reuse_loc_lists && !empty(w:syntastic_loclist_set)
    1   0.000009   0.000004         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: setloclist ' . (replace ? '(replace)' : '(new)'))
    1   0.000006   0.000005         call setloclist(0, self.getRaw(), replace ? 'r' : ' ')
    1              0.000000         try
                                        " Vim 7.4.2200 or later
    1              0.000004             call setloclist(0, [], 'r', { 'title': ':SyntasticCheck ' . self._name })
                                    catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                        " do nothing
    1              0.000001         endtry
    1   0.000006   0.000002         call syntastic#util#setLastTick(self._owner)
    1              0.000003         let w:syntastic_loclist_set = [self._owner, getbufvar(self._owner, 'syntastic_lasttick')]
    1              0.000000     endif

FUNCTION  64()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:312
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: show')
                                call self.setloclist(0)
                            
                                if !&previewwindow && !self.isEmpty()
                                    let num = winnr()
                                    execute 'lopen ' . syntastic#util#var('loc_list_height')
                                    if num != winnr()
                                        execute num . 'wincmd w'
                                    endif
                            
                                    " try to find the loclist window and set w:quickfix_title
                                    let errors = getloclist(0)
                                    for buf in tabpagebuflist()
                                        if buflisted(buf) && bufloaded(buf) && getbufvar(buf, '&buftype') ==# 'quickfix'
                                            let win = bufwinnr(buf)
                                            let title = getwinvar(win, 'quickfix_title')
                            
                                            " TODO: try to make sure we actually own this window; sadly,
                                            " errors == getloclist(0) is the only somewhat safe way to
                                            " achieve that
                                            if strpart(title, 0, 16) ==# ':SyntasticCheck ' || ( (title ==# '' || title ==# ':setloclist()') && errors == getloclist(0) )
                                                call setwinvar(win, 'quickfix_title', ':SyntasticCheck ' . self._name)
                                                call setbufvar(buf, 'syntastic_owner_buffer', self._owner)
                                            endif
                                        endif
                                    endfor
                                endif

FUNCTION  65()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim:10
Called 1 time
Total time:   0.000024
 Self time:   0.000012

count  total (s)   self (s)
    1              0.000002     if !exists('s:SyntasticModeMapInstance')
    1              0.000004         let s:SyntasticModeMapInstance = copy(self)
    1   0.000016   0.000004         call s:SyntasticModeMapInstance.synch()
    1              0.000000     endif
                            
    1              0.000001     return s:SyntasticModeMapInstance

FUNCTION  66()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim:19
Called 3 times
Total time:   0.000083
 Self time:   0.000083

count  total (s)   self (s)
    3              0.000014     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
    3              0.000005     else
    3              0.000008         let self._mode = 'active'
    3              0.000010         let self._activeFiletypes = []
    3              0.000006         let self._passiveFiletypes = []
    3              0.000003     endif

FUNCTION  67()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim:31
Called 1 time
Total time:   0.000052
 Self time:   0.000017

count  total (s)   self (s)
    1   0.000011   0.000003     let registry = g:SyntasticRegistry.Instance()
    1   0.000025   0.000004     let fts = registry.resolveFiletypes(a:filetype)
                            
    1   0.000004   0.000003     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
    1              0.000001     else
    1   0.000009   0.000004         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  68()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim:42
Called 1 time
Total time:   0.000063
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000002     let local_mode = getbufvar(a:buf, 'syntastic_mode')
    1              0.000002     if local_mode ==# 'active' || local_mode ==# 'passive'
                                    return local_mode ==# 'active'
    1              0.000000     endif
                            
    1   0.000056   0.000004     return self.allowsAutoChecking(getbufvar(a:buf, '&filetype'))

FUNCTION  69()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim:51
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return self._mode ==# 'passive'

FUNCTION  <SNR>28__normalise_filetype()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:401
Called 2 times
Total time:   0.000020
 Self time:   0.000020

count  total (s)   self (s)
    2              0.000007     let ft = get(s:_DEFAULT_FILETYPE_MAP, a:ftalias, a:ftalias)
    2              0.000005     let ft = get(g:syntastic_filetype_map, ft, ft)
    2              0.000006     let ft = substitute(ft, '\m-', '_', 'g')
    2              0.000001     return ft

FUNCTION  70()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim:55
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call self.synch()
                            
                                if self._mode ==# 'active'
                                    let self._mode = 'passive'
                                else
                                    let self._mode = 'active'
                                endif
                            
                                "XXX Changing a global variable.  Tsk, tsk...
                                if !exists('g:syntastic_mode_map')
                                    let g:syntastic_mode_map = {}
                                endif
                                let g:syntastic_mode_map['mode'] = self._mode

FUNCTION  71()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim:71
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                echo 'Syntastic: ' . self._mode . ' mode enabled'

FUNCTION  72()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim:75
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                echomsg 'Syntastic version: ' . g:syntastic_version
                                let type = len(a:filetypes) ? a:filetypes[0] : &filetype
                                echomsg 'Info for filetype: ' . type
                            
                                call self.synch()
                                echomsg 'Global mode: ' . self._mode
                                if self._mode ==# 'active'
                                    if len(self._passiveFiletypes)
                                        let plural = len(self._passiveFiletypes) != 1 ? 's' : ''
                                        echomsg 'Passive filetype' . plural . ': ' . join(sort(copy(self._passiveFiletypes)))
                                    endif
                                else
                                    if len(self._activeFiletypes)
                                        let plural = len(self._activeFiletypes) != 1 ? 's' : ''
                                        echomsg 'Active filetype' . plural . ': ' . join(sort(copy(self._activeFiletypes)))
                                    endif
                                endif
                                echomsg 'Filetype ' . type . ' is ' . (self.allowsAutoChecking(type) ? 'active' : 'passive')
                            
                                if !len(a:filetypes)
                                    if exists('b:syntastic_mode') && (b:syntastic_mode ==# 'active' || b:syntastic_mode ==# 'passive')
                                        echomsg 'Local mode: ' . b:syntastic_mode
                                    endif
                            
                                    echomsg 'The current file will ' . (self.doAutoChecking(bufnr('')) ? '' : 'not ') . 'be checked automatically'
                                endif

FUNCTION  73()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim:108
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return !empty(filter(copy(a:filetypes), 'index(self._activeFiletypes, v:val) != -1'))

FUNCTION  74()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/modemap.vim:112
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000005     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  75()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/notifiers.vim:16
Called 1 time
Total time:   0.000136
 Self time:   0.000011

count  total (s)   self (s)
    1              0.000002     if !exists('s:SyntasticNotifiersInstance')
    1              0.000003         let s:SyntasticNotifiersInstance = copy(self)
    1   0.000128   0.000003         call s:SyntasticNotifiersInstance._initNotifiers()
    1              0.000001     endif
                            
    1              0.000001     return s:SyntasticNotifiersInstance

FUNCTION  76()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/notifiers.vim:25
Called 1 time
Total time:   0.000693
 Self time:   0.000198

count  total (s)   self (s)
    1   0.000024   0.000007     if !syntastic#util#bufIsActive(bufnr('')) || (!a:loclist.isEmpty() && !a:loclist.isNewerThan([]))
                                    " loclist not fully constructed yet
                                    return
    1              0.000001     endif
                            
    1   0.000009   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: refresh')
    6              0.000005     for type in self._enabled_types
    5              0.000033         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
    5   0.000078   0.000031         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
    5              0.000014             if index(s:_PERSISTENT_NOTIFIERS, type) > -1
                                            " refresh only if loclist has changed since last call
    2              0.000007                 if !exists('b:syntastic_private_' . type . '_stamp')
                                                let b:syntastic_private_{type}_stamp = []
    2              0.000001                 endif
    2   0.000071   0.000010                 if a:loclist.isNewerThan(b:syntastic_private_{type}_stamp) || a:loclist.isEmpty()
    2   0.000188   0.000006                     call self._notifier[type].refresh(a:loclist)
    2   0.000031   0.000010                     let b:syntastic_private_{type}_stamp = syntastic#util#stamp()
    2              0.000002                 endif
    3              0.000000             else
    3   0.000172   0.000010                 call self._notifier[type].refresh(a:loclist)
    5              0.000002             endif
    5              0.000003         endif
    6              0.000003     endfor

FUNCTION  77()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/notifiers.vim:51
Called 1 time
Total time:   0.000170
 Self time:   0.000119

count  total (s)   self (s)
    1   0.000009   0.000003     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'notifiers: reset')
    6              0.000006     for type in self._enabled_types
    5              0.000036         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
    5              0.000017         if has_key(g:{class}, 'reset')
    3   0.000057   0.000012             call self._notifier[type].reset(a:loclist)
    5              0.000002         endif
                            
                                    " also reset stamps
    5              0.000010         if index(s:_PERSISTENT_NOTIFIERS, type) > -1
    2              0.000006             let b:syntastic_private_{type}_stamp = []
    5              0.000002         endif
    6              0.000003     endfor

FUNCTION  78()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/notifiers.vim:74
Called 1 time
Total time:   0.000125
 Self time:   0.000075

count  total (s)   self (s)
    1              0.000002     let self._notifier = {}
    6              0.000007     for type in s:_NOTIFIER_TYPES
    5              0.000035         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
    5   0.000070   0.000020         let self._notifier[type] = g:{class}.New()
    6              0.000002     endfor
                            
    1              0.000003     let self._enabled_types = copy(s:_NOTIFIER_TYPES)

FUNCTION  79()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:164
Called 3 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    3              0.000008     if !exists('s:SyntasticRegistryInstance')
    1              0.000006         let s:SyntasticRegistryInstance = copy(self)
    1              0.000002         let s:SyntasticRegistryInstance._checkerMap = {}
    3              0.000002     endif
                            
    3              0.000004     return s:SyntasticRegistryInstance

FUNCTION  <SNR>30_QuitPreHook()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:370
Called 1 time
Total time:   0.000628
 Self time:   0.000150

count  total (s)   self (s)
    1   0.000298   0.000029     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000074   0.000039     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: QuitPre, buffer ' . buf . ' = ' . string(a:fname))
                            
    1   0.000053   0.000011     if !syntastic#util#var('check_on_wq')
    1   0.000149   0.000017         call syntastic#util#setWids()
    1              0.000025         call add(s:_quit_pre, buf . '_' . getbufvar(buf, 'changetick') . '_' . w:syntastic_wid)
    1              0.000003     endif
                            
    1              0.000012     if !empty(get(w:, 'syntastic_loclist_set', []))
                                    call SyntasticLoclistHide()
    1              0.000002     endif

FUNCTION  syntastic#log#deprecationWarn()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:40
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if exists('g:syntastic_' . a:old) && !exists('g:syntastic_' . a:new)
                                    let msg = 'variable g:syntastic_' . a:old . ' is deprecated, please use '
                            
                                    if a:0
                                        let OLD_VAR = g:syntastic_{a:old}
                                        try
                                            let NEW_VAR = eval(a:1)
                                            let msg .= 'in its stead: let g:syntastic_' . a:new . ' = ' . string(NEW_VAR)
                                            let g:syntastic_{a:new} = NEW_VAR
                                        catch
                                            let msg .= 'g:syntastic_' . a:new . ' instead'
                                        endtry
                                    else
                                        let msg .= 'g:syntastic_' . a:new . ' instead'
                                        let g:syntastic_{a:new} = g:syntastic_{a:old}
                                    endif
                            
                                    call syntastic#log#oneTimeWarn(msg)
                                endif

FUNCTION  80()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:173
Called 1 time
Total time:   0.000116
 Self time:   0.000025

count  total (s)   self (s)
    1   0.000012   0.000004     let registry = g:SyntasticRegistry.Instance()
                            
    1              0.000002     if has_key(a:args, 'redirect')
                                    let [ft, name] = split(a:args['redirect'], '/')
                                    call registry._loadCheckersFor(ft, 1)
                            
                                    let clone = get(registry._checkerMap[ft], name, {})
                                    if empty(clone)
                                        throw 'Syntastic: Checker ' . a:args['redirect'] . ' redirects to unregistered checker ' . ft . '/' . name
                                    endif
                            
                                    let checker = g:SyntasticChecker.New(a:args, clone)
    1              0.000000     else
    1   0.000069   0.000005         let checker = g:SyntasticChecker.New(a:args)
    1              0.000001     endif
    1   0.000021   0.000002     call registry._registerChecker(checker)

FUNCTION  81()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:196
Called 1 time
Total time:   0.000624
 Self time:   0.000073

count  total (s)   self (s)
    1   0.000023   0.000003     let ftlist = self.resolveFiletypes(a:ftalias)
                            
    1              0.000005     let names = !empty(a:hints_list) ? a:hints_list : exists('b:syntastic_checkers') ? b:syntastic_checkers : []
                            
    1              0.000001     let cnames = []
    1              0.000001     if !empty(names)
                                    for name in names
                                        if name !~# '/'
                                            for ft in ftlist
                                                call add(cnames, ft . '/' . name)
                                            endfor
                                        else
                                            call add(cnames, name)
                                        endif
                                    endfor
    1              0.000000     else
    2              0.000003         for ft in ftlist
    1   0.000021   0.000003             call self._sanityCheck(ft)
    1              0.000006             let defs = exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:_DEFAULT_CHECKERS, ft, [])
    1              0.000010             call extend(cnames, map(copy(defs), 'stridx(v:val, "/") < 0 ? ft . "/" . v:val : v:val' ))
    2              0.000001         endfor
    1              0.000000     endif
    1   0.000023   0.000003     let cnames = syntastic#util#unique(cnames)
                            
    2   0.000026   0.000009     for ft in syntastic#util#unique(map( copy(cnames), 'v:val[: stridx(v:val, "/")-1]' ))
    1   0.000455   0.000004         call self._loadCheckersFor(ft, 0)
    2              0.000001     endfor
                            
    1   0.000027   0.000002     return self._filterCheckersByName(cnames)

FUNCTION  82()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:234
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return filter(self.getCheckers(a:ftalias, a:hints_list), 'v:val.isAvailable()')

FUNCTION  83()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:240
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return filter(self.getCheckers(a:ftalias, a:hints_list), 'v:val.isDisabled() && v:val.isAvailable()')

FUNCTION  84()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:244
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let types = keys(s:_DEFAULT_CHECKERS)
                            
                                call extend(types, keys(s:_DEFAULT_FILETYPE_MAP))
                            
                                if exists('g:syntastic_filetype_map')
                                    call extend(types, keys(g:syntastic_filetype_map))
                                endif
                            
                                if exists('g:syntastic_extra_filetypes') && type(g:syntastic_extra_filetypes) == type([])
                                    call extend(types, g:syntastic_extra_filetypes)
                                endif
                            
                                return syntastic#util#unique(types)

FUNCTION  85()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:260
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let ft = s:_normalise_filetype(a:ftalias)
                                call self._loadCheckersFor(ft, 0)
                                return keys(filter( copy(self._checkerMap[ft]), 'v:val.isAvailable()' ))

FUNCTION  86()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:266
Called 2 times
Total time:   0.000041
 Self time:   0.000021

count  total (s)   self (s)
    2   0.000040   0.000020     return map(split( get(g:syntastic_filetype_map, a:ftalias, a:ftalias), '\m\.' ), 's:_normalise_filetype(v:val)')

FUNCTION  87()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:270
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let ft_list = syntastic#util#unique(self.resolveFiletypes(empty(a:ftalias_list) ? &filetype : a:ftalias_list[0]))
                                if len(ft_list) != 1
                                    let available = []
                                    let active = []
                                    let disabled = []
                            
                                    for ft in ft_list
                                        call extend(available, map( self.getNamesOfAvailableCheckers(ft), 'ft . "/" . v:val' ))
                                        call extend(active, map( self.getCheckersAvailable(ft, []), 'ft . "/" . v:val.getName()' ))
                                        call extend(disabled, map( self.getCheckersDisabled(ft, []), 'ft . "/" . v:val.getName()' ))
                                    endfor
                                else
                                    let ft = ft_list[0]
                                    let available = self.getNamesOfAvailableCheckers(ft)
                                    let active = map(self.getCheckersAvailable(ft, []), 'ft ==# v:val.getFiletype() ? v:val.getName() : v:val.getCName()')
                                    let disabled = map(self.getCheckersDisabled(ft, []), 'ft ==# v:val.getFiletype() ? v:val.getName() : v:val.getCName()')
                                endif
                            
                                let cnt = len(available)
                                let plural = cnt != 1 ? 's' : ''
                                let cklist = cnt ? join(sort(available)) : '-'
                                echomsg 'Available checker' . plural . ': ' . cklist
                            
                                let cnt = len(active)
                                let plural = cnt != 1 ? 's' : ''
                                let cklist = cnt ? join(active) : '-'
                                echomsg 'Currently enabled checker' . plural . ': ' . cklist
                            
                                let cnt = len(disabled)
                                let plural = cnt != 1 ? 's' : ''
                                if len(disabled)
                                    let cklist = join(sort(disabled, 's:_compare_checker_names'))
                                    echomsg 'Checker' . plural . ' disabled for security reasons: ' . cklist
                                endif
                            
                                " Eclim feels entitled to mess with syntastic's variables {{{3
                                if exists(':EclimValidate') && get(g:, 'EclimFileTypeValidate', 1)
                                    let disabled = filter(copy(ft_list), 's:_disabled_by_eclim(v:val)')
                                    let cnt = len(disabled)
                                    if cnt
                                        let plural = cnt != 1 ? 's' : ''
                                        let cklist = join(disabled, ', ')
                                        echomsg 'Checkers for filetype' . plural . ' ' . cklist . ' possibly disabled by Eclim'
                                    endif
                                endif
                                " }}}3
                            
                                " So does YouCompleteMe {{{3
                                if exists('g:loaded_youcompleteme') && get(g:, 'ycm_show_diagnostics_ui', get(g:, 'ycm_register_as_syntastic_checker', 1))
                                    let disabled = filter(copy(ft_list), 's:_disabled_by_ycm(v:val)')
                                    let cnt = len(disabled)
                                    if cnt
                                        let plural = cnt != 1 ? 's' : ''
                                        let cklist = join(disabled, ', ')
                                        echomsg 'Checkers for filetype' . plural . ' ' . cklist . ' possibly disabled by YouCompleteMe'
                                    endif
                                endif
                                " }}}3

FUNCTION  88()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:335
Called 1 time
Total time:   0.000019
 Self time:   0.000016

count  total (s)   self (s)
    1   0.000005   0.000003     let ft = a:checker.getFiletype()
    1              0.000001     if !has_key(self._checkerMap, ft)
    1              0.000002         let self._checkerMap[ft] = {}
    1              0.000001     endif
                            
    1   0.000004   0.000003     let name = a:checker.getName()
    1              0.000002     if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
    1              0.000000     endif
                            
    1              0.000001     let self._checkerMap[ft][name] = a:checker

FUNCTION  89()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:349
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    1              0.000003     let sep_idx = stridx(a:cname, '/')
    1              0.000001     if sep_idx > 0
    1              0.000003         let ft = a:cname[: sep_idx-1]
    1              0.000002         let name = a:cname[sep_idx+1 :]
                                else
                                    let ft = &filetype
                                    let name = a:cname
    1              0.000000     endif
    1              0.000003     return get(self._checkerMap[ft], name, {})

FUNCTION  syntastic#util#system()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:31
Called 2 times
Total time:   0.008005
 Self time:   0.000398

count  total (s)   self (s)
    2              0.000004     let old_shell = &shell
    2              0.000005     let old_lc_messages = $LC_MESSAGES
    2              0.000003     let old_lc_all = $LC_ALL
                            
    2   0.000028   0.000010     let &shell = syntastic#util#var('shell')
    2              0.000005     let $LC_MESSAGES = 'C'
    2              0.000002     let $LC_ALL = ''
                            
    2              0.000002     let crashed = 0
    2              0.000004     let cmd_start = reltime()
    2              0.000000     try
    2   0.007734   0.000160         let out = system(a:command)
                                catch
                                    if v:exception =~# '\m^Vim\%((\a\+)\)\=:\%(E145\|E484\|E684\)'
                                        " XXX re-throwing unmodified v:exception triggers E608
                                        throw substitute(v:exception, '.*:\(E145\|E484\|E684\).*', '\1', '')
                                    endif
                            
                                    let crashed = 1
                                    call syntastic#log#error('exception running system(' . string(a:command) . '): ' . v:exception)
                                    if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
                                    else
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
                                    endif
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '$PATH = ' . string($PATH))
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
                                    let out = ''
    2              0.000002     endtry
    2              0.000056     let cmd_time = split(reltimestr(reltime(cmd_start)))[0]
                            
    2              0.000010     let $LC_ALL = old_lc_all
    2              0.000004     let $LC_MESSAGES = old_lc_messages
                            
    2              0.000011     let &shell = old_shell
                            
    2              0.000007     if !crashed && exists('g:_SYNTASTIC_DEBUG_TRACE')
    1   0.000026   0.000011         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'system: command run in ' . cmd_time . 's')
    2              0.000000     endif
                            
    2              0.000004     return out

FUNCTION  <SNR>30__add_to_errors()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:780
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                for err in a:errors
                                    for key in keys(a:options)
                                        if !has_key(err, key) || empty(err[key])
                                            let err[key] = a:options[key]
                                        endif
                                    endfor
                                endfor
                            
                                return a:errors

FUNCTION  <SNR>30_BufEnterHook()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:319
Called 1 time
Total time:   0.000161
 Self time:   0.000048

count  total (s)   self (s)
    1   0.000110   0.000004     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000017   0.000010     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    1              0.000003     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    1              0.000004         let idx = index(reverse(copy(s:_check_stack)), buf)
    1              0.000000         if idx >= 0
    1              0.000002             if !has('vim_starting')
                                            call remove(s:_check_stack, -idx - 1)
                                            call s:UpdateErrors(buf, 1, [])
    1              0.000001             endif
                                    elseif &buftype ==# ''
                                        call s:notifiers.refresh(g:SyntasticLoclist.current())
    1              0.000001         endif
                                elseif &buftype ==# 'quickfix'
                                    " TODO: this is needed because in recent versions of Vim lclose
                                    " can no longer be called from BufWinLeave
                                    " TODO: at this point there is no b:syntastic_loclist
                                    let loclist = filter(copy(getloclist(0)), 'v:val["valid"]')
                                    let owner = str2nr(getbufvar(buf, 'syntastic_owner_buffer'))
                                    let buffers = syntastic#util#unique(map(loclist, 'v:val["bufnr"]') + (owner ? [owner] : []))
                                    if !empty(get(w:, 'syntastic_loclist_set', [])) && !empty(loclist) && empty(filter( buffers, 'syntastic#util#bufIsActive(v:val)' ))
                                        call SyntasticLoclistHide()
                                    endif
    1              0.000000     endif

FUNCTION  syntastic#log#warn()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:17
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                echohl WarningMsg
                                echomsg 'syntastic: warning: ' . a:msg
                                echohl None

FUNCTION  syntastic#log#debugShowVariables()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:103
Called 3 times
Total time:   0.000045
 Self time:   0.000032

count  total (s)   self (s)
    3   0.000033   0.000020     if !s:_isDebugEnabled(a:level)
    3              0.000005         return
                                endif
                            
                                let leader = s:_log_timestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type('') ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_format_variable(name)
                                    if msg !=# ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  90()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:361
Called 1 time
Total time:   0.000025
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000024   0.000008     return filter( map(copy(a:cnames), 'self._findChecker(v:val)'), '!empty(v:val)' )

FUNCTION  91()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:365
Called 1 time
Total time:   0.000451
 Self time:   0.000235

count  total (s)   self (s)
    1              0.000002     if !a:force && has_key(self._checkerMap, a:filetype)
                                    return
    1              0.000001     endif
                            
    1   0.000443   0.000227     execute 'runtime! syntax_checkers/' . a:filetype . '/*.vim'
                            
    1              0.000003     if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
    1              0.000000     endif

FUNCTION  92()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:378
Called 1 time
Total time:   0.000018
 Self time:   0.000018

count  total (s)   self (s)
    1              0.000004     if exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checkers) != type([])
                            
                                    unlet! g:syntastic_{a:filetype}_checkers
                                    call syntastic#log#error('variable g:syntastic_' . a:filetype . '_checkers has to be a list of strings')
    1              0.000000     endif
                            
    1              0.000004     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers') && type(g:syntastic_{a:filetype}_checker) == type('')
                            
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
    1              0.000001     endif

FUNCTION  93()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/signs.vim:22
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004     let newObj = copy(self)
    1              0.000001     return newObj

FUNCTION  94()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/signs.vim:27
Called 2 times
Total time:   0.000026
 Self time:   0.000010

count  total (s)   self (s)
    2   0.000026   0.000010     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  95()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/signs.vim:31
Called 1 time
Total time:   0.000158
 Self time:   0.000024

count  total (s)   self (s)
    1   0.000010   0.000004     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'signs: refresh')
                            
    1   0.000009   0.000003     let old_signs = copy(self._bufSignIds())
    1   0.000013   0.000001     if self.enabled()
    1              0.000002         if !s:setup_done
    1   0.000072   0.000002             call self._setup()
    1              0.000002             let s:setup_done = 1
    1              0.000001             lockvar s:setup_done
    1              0.000000         endif
                            
    1   0.000034   0.000003         call self._signErrors(a:loclist)
    1              0.000001     endif
    1   0.000012   0.000003     call self._removeSigns(old_signs)

FUNCTION  96()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/signs.vim:52
Called 1 time
Total time:   0.000070
 Self time:   0.000070

count  total (s)   self (s)
    1              0.000002     if has('signs')
    1              0.000008         if !hlexists('SyntasticErrorSign')
    1              0.000006             highlight link SyntasticErrorSign error
    1              0.000000         endif
    1              0.000004         if !hlexists('SyntasticWarningSign')
    1              0.000003             highlight link SyntasticWarningSign todo
    1              0.000000         endif
    1              0.000003         if !hlexists('SyntasticStyleErrorSign')
    1              0.000003             highlight link SyntasticStyleErrorSign SyntasticErrorSign
    1              0.000000         endif
    1              0.000003         if !hlexists('SyntasticStyleWarningSign')
    1              0.000002             highlight link SyntasticStyleWarningSign SyntasticWarningSign
    1              0.000001         endif
    1              0.000002         if !hlexists('SyntasticStyleErrorLine')
    1              0.000003             highlight link SyntasticStyleErrorLine SyntasticErrorLine
    1              0.000001         endif
    1              0.000002         if !hlexists('SyntasticStyleWarningLine')
    1              0.000004             highlight link SyntasticStyleWarningLine SyntasticWarningLine
    1              0.000000         endif
                            
                                    " define the signs used to display syntax and style errors/warns
    1              0.000008         execute 'sign define SyntasticError text=' . g:syntastic_error_symbol . ' texthl=SyntasticErrorSign linehl=SyntasticErrorLine'
    1              0.000005         execute 'sign define SyntasticWarning text=' . g:syntastic_warning_symbol . ' texthl=SyntasticWarningSign linehl=SyntasticWarningLine'
    1              0.000004         execute 'sign define SyntasticStyleError text=' . g:syntastic_style_error_symbol . ' texthl=SyntasticStyleErrorSign linehl=SyntasticStyleErrorLine'
    1              0.000004         execute 'sign define SyntasticStyleWarning text=' . g:syntastic_style_warning_symbol . ' texthl=SyntasticStyleWarningSign linehl=SyntasticStyleWarningLine'
    1              0.000001     endif

FUNCTION  97()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/signs.vim:86
Called 1 time
Total time:   0.000031
 Self time:   0.000030

count  total (s)   self (s)
    1              0.000001     let loclist = a:loclist
    1   0.000004   0.000003     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute 'sign place ' . s:next_sign_id . ' line=' . i['lnum'] . ' name=' . sign_type . ' buffer=' . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
    1              0.000001     endif

FUNCTION  98()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/signs.vim:119
Called 1 time
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    1              0.000002     if has('signs')
    1              0.000003         for s in reverse(copy(a:ids))
                                        execute 'sign unplace ' . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
    1              0.000001         endfor
    1              0.000000     endif

FUNCTION  99()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/signs.vim:129
Called 1 time
Total time:   0.000006
 Self time:   0.000006

count  total (s)   self (s)
    1              0.000002     if !exists('b:syntastic_private_sign_ids')
    1              0.000001         let b:syntastic_private_sign_ids = []
    1              0.000001     endif
    1              0.000001     return b:syntastic_private_sign_ids

FUNCTION  syntastic#util#getbufvar()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:126
Called 157 times
Total time:   0.002513
 Self time:   0.002513

count  total (s)   self (s)
  157              0.002303     return a:0 ? s:_getbufvar(a:buf, a:name, a:1) : getbufvar(a:buf, a:name)

FUNCTION  syntastic#util#setWids()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:416
Called 1 time
Total time:   0.000132
 Self time:   0.000132

count  total (s)   self (s)
    2              0.000018     for tab in range(1, tabpagenr('$'))
    2              0.000018         for win in range(1, tabpagewinnr(tab, '$'))
    1              0.000010             if gettabwinvar(tab, win, 'syntastic_wid') ==# ''
    1              0.000020                 call settabwinvar(tab, win, 'syntastic_wid', s:_wid_base . s:_wid_pool)
    1              0.000008                 let s:_wid_pool += 1
    1              0.000002             endif
    2              0.000006         endfor
    2              0.000005     endfor

FUNCTION  syntastic#util#isRunningWindows()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:11
Called 2 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    2              0.000014     return has('win16') || has('win32') || has('win64')

FUNCTION  <SNR>30_UpdateErrors()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:389
Called 2 times
Total time:   0.007671
 Self time:   0.000206

count  total (s)   self (s)
    2   0.000058   0.000019     call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'version')
    2   0.000048   0.000020     call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
    2   0.000040   0.000014     call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)
    2   0.000059   0.000034     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
                            
    2   0.000089   0.000018     call s:modemap.synch()
                            
    2   0.000261   0.000018     if s:_skip_file(a:buf)
    1              0.000002         return
    1              0.000001     endif
                            
    1   0.000068   0.000005     let run_checks = !a:auto_invoked || s:modemap.doAutoChecking(a:buf)
    1              0.000001     if run_checks
    1   0.006207   0.000011         call s:CacheErrors(a:buf, a:checker_names)
    1   0.000009   0.000004         call syntastic#util#setLastTick(a:buf)
                                elseif a:auto_invoked
                                    return
    1              0.000001     endif
                            
    1   0.000020   0.000003     let loclist = g:SyntasticLoclist.current(a:buf)
                            
    1              0.000002     if exists('*SyntasticCheckHook')
                                    call SyntasticCheckHook(loclist.getRaw())
    1              0.000001     endif
                            
                                " populate loclist and jump {{{3
    1   0.000013   0.000004     let do_jump = syntastic#util#var('auto_jump') + 0
    1              0.000001     if do_jump == 2
                                    let do_jump = loclist.getFirstError(1)
    1              0.000001     elseif do_jump == 3
                                    let do_jump = loclist.getFirstError()
    1              0.000001     elseif 0 > do_jump || do_jump > 3
                                    let do_jump = 0
    1              0.000001     endif
                            
    1   0.000010   0.000003     if syntastic#util#var('always_populate_loc_list') || do_jump
    1   0.000047   0.000004         call loclist.setloclist(1)
    1              0.000002         if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: jump')
                                        execute 'silent! lrewind ' . do_jump
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype ==# ''
                                            silent! filetype detect
                                        endif
    1              0.000000         endif
    1              0.000001     endif
                                " }}}3
                            
    1   0.000698   0.000005     call s:notifiers.refresh(loclist)

FUNCTION  syntastic#util#CygwinPath()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:27
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return substitute(syntastic#util#system('cygpath -m ' . syntastic#util#shescape(a:path)), "\n", '', 'g')

FUNCTION  syntastic#util#var()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:170
Called 25 times
Total time:   0.000236
 Self time:   0.000126

count  total (s)   self (s)
   25   0.000234   0.000124     return call('syntastic#util#rawVar', ['syntastic_' . a:name] + a:000)

FUNCTION  syntastic#util#compareLexi()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:191
Called 2 times
Total time:   0.000046
 Self time:   0.000046

count  total (s)   self (s)
    4              0.000010     for idx in range(max([len(a:a), len(a:b)]))
    4              0.000012         let a_element = str2nr(get(a:a, idx, 0))
    4              0.000009         let b_element = str2nr(get(a:b, idx, 0))
    4              0.000005         if a_element != b_element
    2              0.000002             return a_element > b_element ? 1 : -1
    2              0.000001         endif
    2              0.000001     endfor
                                " still here, thus everything matched
                                return 0

FUNCTION  SyntasticReset()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:255
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call s:ClearCache(bufnr(''))
                                call s:notifiers.refresh(g:SyntasticLoclist.New([]))

FUNCTION  syntastic#util#bufVar()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:160
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return call('syntastic#util#bufRawVar', [a:buf, 'syntastic_' . a:name] + a:000)

FUNCTION  <SNR>30_BufReadPostHook()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:301
Called 1 time
Total time:   0.000316
 Self time:   0.000083

count  total (s)   self (s)
    1   0.000052   0.000006     let buf = syntastic#util#fname2buf(a:fname)
    1              0.000002     if g:syntastic_check_on_open && buf > 0
    1   0.000255   0.000068         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufReadPost, buffer ' . buf . ' = ' . string(a:fname))
    1              0.000004         if index(s:_check_stack, buf) == -1
    1              0.000002             call add(s:_check_stack, buf)
    1              0.000000         endif
    1              0.000000     endif

FUNCTION  <SNR>30_BufWinEnterHook()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:346
Called 1 time
Total time:   0.000163
 Self time:   0.000033

count  total (s)   self (s)
    1   0.000127   0.000004     let buf = syntastic#util#fname2buf(a:fname)
    1   0.000018   0.000011     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: BufWinEnter, buffer ' . buf . ' = ' . string(a:fname) . ', &buftype = ' . string(&buftype))
    1              0.000003     if buf > 0 && getbufvar(buf, '&buftype') ==# ''
    1              0.000004         let idx = index(reverse(copy(s:_check_stack)), buf)
    1              0.000005         if idx >= 0 && !has('vim_starting')
                                        call remove(s:_check_stack, -idx - 1)
                                        call s:UpdateErrors(buf, 1, [])
    1              0.000000         endif
    1              0.000001     endif

FUNCTION  syntastic#log#ndebug()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:130
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if s:_isDebugEnabled(a:level)
                                    return
                                endif
                            
                                call syntastic#log#error(a:title)
                                if type(a:messages) == type([])
                                    for msg in a:messages
                                        echomsg msg
                                    endfor
                                else
                                    echomsg a:messages
                                endif

FUNCTION  <SNR>31__getbufvar_dumb()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:613
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let ret = getbufvar(a:buf, a:name)
                                if a:0 && type(ret) == type('') && ret ==# ''
                                    unlet! ret
                                    let ret = a:1
                                endif
                                return ret

FUNCTION  <SNR>25__remove_shadowed_items()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:377
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " keep only the first message at a given column
                                let i = 0
                                while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].scol == a:errors[i].scol
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile
                            
                                " merge messages with the same text
                                let i = 0
                                while i < len(a:errors) - 1
                                    let j = i + 1
                                    let dupes = 0
                                    while j < len(a:errors) && a:errors[j].text == a:errors[i].text
                                        let dupes = 1
                                        let j += 1
                                    endwhile
                                    if dupes
                                        call remove(a:errors, i + 1, j - 1)
                                    endif
                                    let i += 1
                                endwhile

FUNCTION  SyntasticLoclistHide()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:347
Called 1 time
Total time:   0.000010
 Self time:   0.000005

count  total (s)   self (s)
    1   0.000008   0.000003     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_NOTIFICATIONS, 'loclist: hide')
    1              0.000001     silent! lclose

FUNCTION  <SNR>120__log_timestamp_dumb()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:184
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return 'syntastic: ' . split(reltimestr(reltime(g:_SYNTASTIC_START)))[0] . ': '

FUNCTION  syntastic#util#DevNull()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:15
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if syntastic#util#isRunningWindows()
                                    return 'NUL'
                                endif
                                return '/dev/null'

FUNCTION  syntastic#util#wformat()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:436
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:format ==# ''
                                    return a:str
                                endif
                            
                             echomsg string(a:format) . ', ' . string(a:str)
                                let specs = matchlist(a:format, '\v^(-?)(0?)(%([1-9]\d*))?%(\.(\d+))?$')
                                if len(specs) < 5
                                    return a:str
                                endif
                            
                                let flushleft = specs[1] ==# '-'
                                let lpad = specs[2] ==# '0' ? '0' : ' '
                                let minlen = str2nr(specs[3])
                                let maxlen = str2nr(specs[4])
                                let out = substitute(a:str, "\t", ' ', 'g')
                            
                                if maxlen && s:_width(out) > maxlen
                                    let chars = filter(split(out, '\zs\ze', 1), 'v:val !=# ""')
                                    let out = ''
                            
                                    if flushleft
                                        for c in chars
                                            if s:_width(out . c) < maxlen
                                                let out .= c
                                            else
                                                let out .= &encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '>'
                                                break
                                            endif
                                        endfor
                                    else
                                        call reverse(chars)
                                        for c in chars
                                            if s:_width(c . out) < maxlen
                                                let out = c . out
                                            else
                                                let out = (&encoding ==# 'utf-8' && &termencoding ==# 'utf-8' ? "\u2026" : '<') . out
                                                break
                                            endif
                                        endfor
                                    endif
                                endif
                            
                                if minlen && s:_width(out) < minlen
                                    if flushleft
                                        let out .= repeat(' ', minlen - s:_width(out))
                                    else
                                        let out = repeat(lpad, minlen - s:_width(out)) . out
                                    endif
                                endif
                            
                                return out

FUNCTION  <SNR>30_ClearCache()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:447
Called 1 time
Total time:   0.000271
 Self time:   0.000012

count  total (s)   self (s)
    1   0.000056   0.000005     let loclist = g:SyntasticLoclist.current(a:buf)
    1   0.000175   0.000005     call s:notifiers.reset(loclist)
    1   0.000040   0.000002     call loclist.destroy()

FUNCTION  syntastic#util#bufIsActive()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:238
Called 1 time
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
                                " convert to number, or hell breaks loose
    1              0.000003     let buf = str2nr(a:buffer)
                            
    1              0.000002     if !bufloaded(buf) || !buflisted(buf)
                                    return 0
    1              0.000001     endif
                            
                                " get rid of hidden buffers
    1              0.000003     for tab in range(1, tabpagenr('$'))
    1              0.000003         if index(tabpagebuflist(tab), buf) >= 0
    1              0.000001             return 1
                                    endif
                                endfor
                            
                                return 0

FUNCTION  <SNR>30__ignore_file()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:705
Called 2 times
Total time:   0.000032
 Self time:   0.000032

count  total (s)   self (s)
    2              0.000019     let fname = fnamemodify(a:filename, ':p')
    2              0.000005     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
    2              0.000002     endfor
    2              0.000002     return 0

FUNCTION  SyntasticCheck()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:238
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call s:UpdateErrors(bufnr(''), 0, a:000)
                                call syntastic#util#redraw(g:syntastic_full_redraws)

FUNCTION  <SNR>30_CacheErrors()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:454
Called 1 time
Total time:   0.006196
 Self time:   0.000191

count  total (s)   self (s)
    1   0.000012   0.000006     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    1   0.000276   0.000005     call s:ClearCache(a:buf)
    1   0.000028   0.000005     let newLoclist = g:SyntasticLoclist.New([])
    1   0.000006   0.000002     call newLoclist.setOwner(a:buf)
                            
    1   0.000061   0.000003     if !s:_skip_file(a:buf)
                                    " debug logging {{{3
    1   0.000009   0.000003         call syntastic#log#debugShowVariables(g:_SYNTASTIC_DEBUG_TRACE, 'aggregate_errors')
    1   0.000011   0.000003         if syntastic#util#isRunningWindows()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMP = ' . string($TMP) . ', $TEMP = ' . string($TEMP))
    1              0.000001         else
    1   0.000009   0.000004             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TERM = ' . string($TERM))
    1   0.000008   0.000004             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$TMPDIR = ' . string($TMPDIR))
    1              0.000001         endif
    1   0.000009   0.000005         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_CHECKERS, '$PATH = ' . string($PATH))
    1   0.000017   0.000012         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'getcwd() = ' . string(getcwd()))
                                    " }}}3
                            
    1   0.000631   0.000007         let clist = s:registry.getCheckers(getbufvar(a:buf, '&filetype'), a:checker_names)
                            
    1   0.000041   0.000012         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(syntastic#util#unique(map(copy(clist), 'v:val.getFiletype()'))) > 1
    1              0.000003         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    1              0.000002         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    1              0.000001         let names = []
    1              0.000001         let unavailable_checkers = 0
    2              0.000003         for checker in clist
    1   0.000004   0.000002             let cname = checker.getCName()
    1   0.000061   0.000003             if !checker.isAvailable()
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
    1              0.000000             endif
                            
    1   0.000011   0.000005             call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: Invoking checker: ' . cname)
                            
    1   0.004834   0.000007             let loclist = checker.getLocList()
                            
    1   0.000005   0.000003             if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.wantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', loclist)
                                            endif
                            
                                            call newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
    1              0.000001             endif
    2              0.000003         endfor
                            
                                    " set names {{{3
    1              0.000001         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
    1              0.000001         endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    1              0.000002         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
    1              0.000000         endif
                                    " }}}3
                            
    1   0.000009   0.000003         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'aggregated:', newLoclist)
    1              0.000001         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'sorted:', newLoclist)
    1              0.000001         endif
    1              0.000000     endif
                            
    1   0.000060   0.000003     call newLoclist.deploy()

FUNCTION  <SNR>30__skip_file()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:730
Called 3 times
Total time:   0.000301
 Self time:   0.000143

count  total (s)   self (s)
    3              0.000014     let fname = bufname(a:buf)
    3   0.000223   0.000089     let skip = s:_is_quitting(a:buf) || getbufvar(a:buf, 'syntastic_skip_checks') || (getbufvar(a:buf, '&buftype') !=# '') || !filereadable(fname) || getwinvar(0, '&diff') || getwinvar(0, '&previewwindow') || s:_ignore_file(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    3              0.000006     if skip
    1   0.000040   0.000016         call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, '_skip_file: skipping checks')
    3              0.000003     endif
    3              0.000005     return skip

FUNCTION  10()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:64
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)
    1              0.000001     return self._name

FUNCTION  <SNR>31__translateFilter()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:494
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let conditions = []
                                for k in keys(a:filters)
                                    if type(a:filters[k]) == type([])
                                        call extend(conditions, map(copy(a:filters[k]), 's:_translateElement(k, v:val)'))
                                    else
                                        call add(conditions, s:_translateElement(k, a:filters[k]))
                                    endif
                                endfor
                            
                                if conditions == []
                                    let conditions = ['1']
                                endif
                                return len(conditions) == 1 ? conditions[0] : join(map(conditions, '"(" . v:val . ")"'), ' && ')

FUNCTION  <SNR>120__isDebugEnabled_dumb()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:153
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                " poor man's bit test for bit N, assuming a:level == 2**N
                                return (g:syntastic_debug / a:level) % 2

FUNCTION  <SNR>28__disabled_by_ycm()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:418
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return index(s:_YCM_TYPES, a:filetype) >= 0

FUNCTION  SyntasticBalloonsExprNotifier()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/balloons.vim:49
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('b:syntastic_private_balloons')
                                    return ''
                                endif
                                return get(b:syntastic_private_balloons, v:beval_lnum, '')

FUNCTION  <SNR>30_VimEnterHook()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:359
Called 1 time
Total time:   0.007272
 Self time:   0.000033

count  total (s)   self (s)
    1              0.000002     let buf = bufnr('')
    1   0.000019   0.000010     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_AUTOCOMMANDS, 'autocmd: VimEnter, buffer ' . buf . ' = ' . string(bufname(buf)) . ', &buftype = ' . string(&buftype))
    1              0.000005     let idx = index(reverse(copy(s:_check_stack)), buf)
    1              0.000003     if idx >= 0 && getbufvar(buf, '&buftype') ==# ''
    1              0.000003         call remove(s:_check_stack, -idx - 1)
    1   0.007237   0.000007         call s:UpdateErrors(buf, 1, [])
    1              0.000001     endif

FUNCTION  syntastic#util#screenWidth()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:203
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let chunks = split(a:str, "\t", 1)
                                let width = s:_width(chunks[-1])
                                for c in chunks[:-2]
                                    let cwidth = s:_width(c)
                                    let width += cwidth + a:tabstop - cwidth % a:tabstop
                                endfor
                                return width

FUNCTION  syntastic#util#parseVersion()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:175
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return map(split(matchstr( a:version, a:0 ? a:1 : '\v^\D*\zs\d+(\.\d+)+\ze' ), '\m\.'), 'str2nr(v:val)')

FUNCTION  SyntasticToggleMode()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:260
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call s:modemap.toggleMode()
                                call s:ClearCache(bufnr(''))
                                call s:notifiers.refresh(g:SyntasticLoclist.New([]))
                                call s:modemap.echoMode()

FUNCTION  syntastic#log#info()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:13
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                echomsg 'syntastic: info: ' . a:msg

FUNCTION  <SNR>23__is_same_index()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/cursor.vim:96
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:old_line >= 0 && a:line == a:old_line && a:idx >= 0
                                    if len(a:messages) <= 1
                                        return 1
                                    endif
                            
                                    if a:messages[a:idx].scol <= a:column || a:idx == 0
                                        if a:idx == len(a:messages) - 1 || a:column < a:messages[a:idx + 1].scol
                                            return 1
                                        else
                                            return 0
                                        endif
                                    else
                                        return 0
                                    endif
                                else
                                    return 0
                                endif

FUNCTION  syntastic#log#debugDump()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:122
Called 2 times
Total time:   0.000026
 Self time:   0.000016

count  total (s)   self (s)
    2   0.000021   0.000011     if !s:_isDebugEnabled(a:level)
    2              0.000004         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:_SYNTASTIC_DEFAULTS)) )

FUNCTION  syntastic#util#wideMsg()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:214
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let old_ruler = &ruler
                                let old_showcmd = &showcmd
                            
                                "This is here because it is possible for some error messages to
                                "begin with \n which will cause a "press enter" prompt.
                                let msg = substitute(a:msg, "\n", '', 'g')
                            
                                "convert tabs to spaces so that the tabs count towards the window
                                "width as the proper amount of characters
                                let chunks = split(msg, "\t", 1)
                                let msg = join(map(chunks[:-2], 'v:val . repeat(" ", &tabstop - s:_width(v:val) % &tabstop)'), '') . chunks[-1]
                                let msg = strpart(msg, 0, &columns - 1)
                            
                                set noruler noshowcmd
                                call syntastic#util#redraw(0)
                            
                                echo msg
                            
                                let &ruler = old_ruler
                                let &showcmd = old_showcmd

FUNCTION  syntastic#util#fname2buf()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:306
Called 5 times
Total time:   0.000782
 Self time:   0.000782

count  total (s)   self (s)
    5              0.000037     if exists('+shellslash')
                                    " bufnr() can't cope with backslashes
                                    let old_shellslash = &shellslash
                                    let &shellslash = 1
    5              0.000009     endif
                            
                                " this is a best-effort attempt to escape file patterns (cf. :h file-pattern)
                                " XXX it fails for filenames containing something like \{2,3}
    5              0.000017     let buf = -1
    7              0.000033     for md in [':~:.', ':~', ':p']
    7              0.000010         try
                                        " Older versions of Vim can throw E94 here
    7              0.000422             let buf = bufnr('^' . escape(fnamemodify(a:fname, md), '\*?,{}[') . '$')
                                    catch
                                        " catch everything
    7              0.000011         endtry
    7              0.000017         if buf != -1
    5              0.000009             break
    2              0.000001         endif
    7              0.000022     endfor
    5              0.000011     if buf == -1
                                    " XXX definitely wrong, but hope is the last thing to die :)
                                    let buf = bufnr(fnamemodify(a:fname, ':p'))
    5              0.000006     endif
                            
    5              0.000019     if exists('+shellslash')
                                    let &shellslash = old_shellslash
    5              0.000005     endif
                            
    5              0.000011     return buf

FUNCTION  <SNR>22__isAvailableDefault()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/checker.vim:276
Called 1 time
Total time:   0.000014
 Self time:   0.000013

count  total (s)   self (s)
    1   0.000013   0.000012     return executable(self.getExec())

FUNCTION  <SNR>28__compare_checker_names()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:422
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:a ==# a:b
                                    return 0
                                endif
                            
                                if stridx(a:a, '/') < 0
                                    if stridx(a:b, '/') < 0
                                        return a:a < a:b ? -1 : 1
                                    else
                                        return -1
                                    endif
                                else
                                    if stridx(a:b, '/') < 0
                                        return 1
                                    else
                                        return a:a < a:b ? -1 : 1
                                    endif
                                endif

FUNCTION  <SNR>31__rmrf()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:574
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('s:rmdir')
                                    let s:rmdir = syntastic#util#shescape(get(g:, 'netrw_localrmdir', 'rmdir'))
                                endif
                            
                                if getftype(a:what) ==# 'dir'
                                    if filewritable(a:what) != 2
                                        return
                                    endif
                            
                                    try
                                        " Vim 7.4.279 and later
                                        let entries = globpath(a:what, '*', 1, 1)
                                    catch /\m^Vim\%((\a\+)\)\=:E118/
                                        let entries = split(globpath(a:what, '*', 1), "\n")
                                    endtry
                                    for f in entries
                                        call s:_rmrf(f)
                                    endfor
                                    silent! call syntastic#util#system(s:rmdir . ' ' . syntastic#util#shescape(a:what))
                                else
                                    silent! call delete(a:what)
                                endif

FUNCTION  SyntasticMake()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:569
Called 1 time
Total time:   0.004317
 Self time:   0.000226

count  total (s)   self (s)
    1   0.000011   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
    1              0.000002     let old_local_errorformat = &l:errorformat
    1              0.000003     let old_errorformat = &errorformat
    1              0.000003     let old_cwd = getcwd()
                                " }}}3
                            
    1              0.000002     if has_key(a:options, 'errorformat')
    1              0.000006         let &errorformat = a:options['errorformat']
    1              0.000002         set errorformat<
    1              0.000001     endif
                            
    1              0.000002     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
    1              0.000001     endif
                            
                                " set environment variables {{{3
    1              0.000001     let env_save = {}
    1              0.000002     if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_][a-z0-9_]*$'
                                            execute 'let env_save[' . string(key) . '] = $' . key
                                            execute 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
    1              0.000000     endif
                                " }}}3
                            
    1   0.004070   0.000012     let err_lines = split(syntastic#util#system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
    1              0.000002     if len(env_save)
                                    for key in keys(env_save)
                                        execute 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
    1              0.000001     endif
                                " }}}3
                            
    1   0.000011   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                            
                                " Does it still make sense to go on?
    1   0.000018   0.000007     let bailout = syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                            
    1              0.000001     if !bailout
    1              0.000002         if has_key(a:options, 'Preprocess')
                                        let err_lines = call(a:options['Preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess (external):', err_lines)
    1              0.000001         elseif has_key(a:options, 'preprocess')
                                        let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                        call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'preprocess:', err_lines)
    1              0.000000         endif
    1              0.000027         noautocmd lgetexpr err_lines
                            
    1              0.000008         let errors = deepcopy(getloclist(0))
                            
    1              0.000001         if has_key(a:options, 'cwd')
                                        execute 'lcd ' . fnameescape(old_cwd)
    1              0.000000         endif
                            
    1              0.000001         try
    1              0.000013             silent lolder
    1              0.000012         catch /\m^Vim\%((\a\+)\)\=:E380/
                                        " E380: At bottom of quickfix stack
    1              0.000004             call setloclist(0, [], 'r')
    1              0.000000             try
                                            " Vim 7.4.2200 or later
    1              0.000003                 call setloclist(0, [], 'r', { 'title': '' })
                                        catch /\m^Vim\%((\a\+)\)\=:E\%(118\|731\)/
                                            " do nothing
    1              0.000001             endtry
                                    catch /\m^Vim\%((\a\+)\)\=:E776/
                                        " E776: No location list
                                        " do nothing
    1              0.000000         endtry
                                else
                                    let errors = []
    1              0.000000     endif
                            
                                " restore options {{{3
    1              0.000005     let &errorformat = old_errorformat
    1              0.000003     let &l:errorformat = old_local_errorformat
                                " }}}3
                            
    1   0.000015   0.000011     if !s:_running_windows && (s:_os_name() =~? 'FreeBSD' || s:_os_name() =~? 'OpenBSD')
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
    1              0.000001     endif
                            
    1              0.000001     if bailout
                                    call syntastic#log#ndebug(g:_SYNTASTIC_DEBUG_LOCLIST, 'checker output:', err_lines)
                                    throw 'Syntastic: checker error'
    1              0.000000     endif
                            
    1   0.000011   0.000005     call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'raw loclist:', errors)
                            
    1              0.000001     if has_key(a:options, 'defaults')
                                    call s:_add_to_errors(errors, a:options['defaults'])
    1              0.000000     endif
                            
                                " Add subtype info if present.
    1              0.000002     if has_key(a:options, 'subtype')
                                    call s:_add_to_errors(errors, { 'subtype': a:options['subtype'] })
    1              0.000000     endif
                            
    1              0.000003     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess (external):', errors)
    1              0.000002     elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:_SYNTASTIC_DEBUG_LOCLIST, 'postprocess:', errors)
    1              0.000001     endif
                            
    1              0.000002     return errors

FUNCTION  <SNR>31__float2str_smart()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:602
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return printf('%.1f', a:val)

FUNCTION  syntastic#util#unique()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:341
Called 5 times
Total time:   0.000098
 Self time:   0.000098

count  total (s)   self (s)
    5              0.000007     let seen = {}
    5              0.000005     let uniques = []
   10              0.000011     for e in a:list
    5              0.000011         let k = string(e)
    5              0.000010         if !has_key(seen, k)
    5              0.000006             let seen[k] = 1
    5              0.000011             call add(uniques, e)
    5              0.000001         endif
   10              0.000006     endfor
    5              0.000004     return uniques

FUNCTION  <SNR>28__disabled_by_eclim()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/registry.vim:408
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if index(s:_ECLIM_TYPES, a:filetype) >= 0
                                    let lang = toupper(a:filetype[0]) . a:filetype[1:]
                                    let ft = a:filetype !=# 'cpp' ? lang : 'C'
                                    return get(g:, 'Eclim' . lang . 'Validate', 1) && !get(g:, 'Eclim' . ft . 'SyntasticEnabled', 0)
                                endif
                            
                                return 0

FUNCTION  <SNR>120__log_timestamp_smart()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:180
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return printf('syntastic: %f: ', reltimefloat(reltime(g:_SYNTASTIC_START)))

FUNCTION  syntastic#util#setLastTick()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:411
Called 2 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    2              0.000009     call setbufvar(a:buf, 'syntastic_lasttick', getbufvar(a:buf, 'changedtick'))

FUNCTION  <SNR>25__translate()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:356
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return 'get(v:val, ' . string(a:key) . ', "") ==? ' . string(a:val)

FUNCTION  syntastic#util#bufRawVar()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:155
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                return s:_getbufvar(a:buf, a:name, get(g:, a:name, a:0 ? a:1 : ''))

FUNCTION  <SNR>120__isDebugEnabled_smart()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/log.vim:149
Called 41 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
   41              0.000123     return and(g:syntastic_debug, a:level)

FUNCTION  58()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:212
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if !exists('self._cachedErrors')
                                    let self._cachedErrors = self.filter({'type': 'E'})
                                endif
                                return self._cachedErrors

FUNCTION  <SNR>25__compare_error_items_by_lines()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:427
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    " sort by screen column
                                    return a:a['scol'] - a:b['scol']
                                endif

FUNCTION  syntastic#util#shexpand()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:360
Called 1 time
Total time:   0.000014
 Self time:   0.000004

count  total (s)   self (s)
    1   0.000014   0.000004     return syntastic#util#shescape(a:0 ? expand(a:string, a:1) : expand(a:string, 1))

FUNCTION  syntastic#util#findGlobInParent()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:268
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let here = fnamemodify(a:where, ':p')
                            
                                let root = syntastic#util#Slash()
                                if syntastic#util#isRunningWindows() && here[1] ==# ':'
                                    " The drive letter is an ever-green source of fun.  That's because
                                    " we don't care about running syntastic on Amiga these days. ;)
                                    let root = fnamemodify(root, ':p')
                                    let root = here[0] . root[1:]
                                endif
                            
                                let old = ''
                                while here !=# ''
                                    try
                                        " Vim 7.4.279 and later
                                        let p = globpath(here, a:what, 1, 1)
                                    catch /\m^Vim\%((\a\+)\)\=:E118/
                                        let p = split(globpath(here, a:what, 1), "\n")
                                    endtry
                            
                                    if !empty(p)
                                        return fnamemodify(p[0], ':p')
                                    elseif here ==? root || here ==? old
                                        break
                                    endif
                            
                                    let old = here
                            
                                    " we use ':h:h' rather than ':h' since ':p' adds a trailing '/'
                                    " if 'here' is a directory
                                    let here = fnamemodify(here, ':p:h:h')
                                endwhile
                            
                                return ''

FUNCTION  SyntasticInfo()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:243
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                call s:modemap.modeInfo(a:000)
                                call s:registry.echoInfoFor(a:000)
                                call s:_explain_skip(a:000)
                                call syntastic#log#debugShowOptions(g:_SYNTASTIC_DEBUG_TRACE, g:_SYNTASTIC_SHELL_OPTIONS)
                                call syntastic#log#debugDump(g:_SYNTASTIC_DEBUG_VARIABLES)

FUNCTION  syntastic#util#dictFilter()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:394
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let rules = s:_translateFilter(a:filter)
                                " call syntastic#log#debug(g:_SYNTASTIC_DEBUG_TRACE, "applying filter:", rules)
                                try
                                    call filter(a:errors, rules)
                                catch /\m^Vim\%((\a\+)\)\=:E/
                                    let msg = matchstr(v:exception, '\m^Vim\%((\a\+)\)\=:\zs.*')
                                    call syntastic#log#error('quiet_messages: ' . msg)
                                endtry

FUNCTION  syntastic#util#argsescape()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:365
Called 15 times
Total time:   0.000094
 Self time:   0.000094

count  total (s)   self (s)
   15              0.000029     if type(a:opt) == type('') && a:opt !=# ''
    3              0.000003         return [a:opt]
   12              0.000018     elseif type(a:opt) == type([])
                                    return map(copy(a:opt), 'syntastic#util#shescape(v:val)')
   12              0.000006     endif
                            
   12              0.000007     return []

FUNCTION  SyntasticStatuslineFlag()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:697
Called 155 times
Total time:   0.038894
 Self time:   0.003099

count  total (s)   self (s)
  155   0.038701   0.002906     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  <SNR>25__compare_error_items_by_columns()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic/loclist.vim:409
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                if a:a['bufnr'] != a:b['bufnr']
                                    " group by file
                                    return a:a['bufnr'] - a:b['bufnr']
                                elseif a:a['lnum'] != a:b['lnum']
                                    " sort by line
                                    return a:a['lnum'] - a:b['lnum']
                                elseif a:a['scol'] != a:b['scol']
                                    " sort by screen column
                                    return a:a['scol'] - a:b['scol']
                                elseif a:a['type'] !=? a:b['type']
                                    " errors take precedence over warnings
                                    return a:a['type'] ==? 'E' ? -1 : 1
                                else
                                    return 0
                                endif

FUNCTION  <SNR>31__translateElement()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/autoload/syntastic/util.vim:510
Called 0 times
Total time:   0.000000
 Self time:   0.000000

count  total (s)   self (s)
                                let fkey = a:key
                                if fkey[0] ==# '!'
                                    let fkey = fkey[1:]
                                    let not = 1
                                else
                                    let not = 0
                                endif
                            
                                if fkey ==? 'level'
                                    let op = not ? ' ==? ' : ' !=? '
                                    let ret = 'v:val["type"]' . op . string(a:term[0])
                                elseif fkey ==? 'type'
                                    if a:term ==? 'style'
                                        let op = not ? ' ==? ' : ' !=? '
                                        let ret = 'get(v:val, "subtype", "")' . op . '"style"'
                                    else
                                        let op = not ? '!' : ''
                                        let ret = op . 'has_key(v:val, "subtype")'
                                    endif
                                elseif fkey ==? 'regex'
                                    let op = not ? ' =~? ' : ' !~? '
                                    let ret = 'v:val["text"]' . op . string(a:term)
                                elseif fkey ==? 'file' || fkey[:4] ==? 'file:'
                                    let op = not ? ' =~# ' : ' !~# '
                                    let ret = 'bufname(str2nr(v:val["bufnr"]))'
                                    let mod = fkey[4:]
                                    if mod !=# ''
                                        let ret = 'fnamemodify(' . ret . ', ' . string(mod) . ')'
                                    endif
                                    let ret .= op . string(a:term)
                                else
                                    call syntastic#log#warn('quiet_messages: ignoring invalid key ' . strtrans(string(fkey)))
                                    let ret = '1'
                                endif
                                return ret

FUNCTION  <SNR>30__os_name()
    Defined: ~/.dotfiles/vim/.vim/plugged/syntastic/plugin/syntastic.vim:792
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000002     return g:_SYNTASTIC_UNAME

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
  155   0.038894   0.003099  SyntasticStatuslineFlag()
  155   0.024862             48()
  157   0.011001   0.008393  39()
    2   0.008005   0.000398  syntastic#util#system()
    2   0.007671   0.000206  <SNR>30_UpdateErrors()
    1   0.007272   0.000033  <SNR>30_VimEnterHook()
    1   0.006196   0.000191  <SNR>30_CacheErrors()
    1   0.004827   0.000012  16()
    1   0.004778   0.000077  15()
    1   0.004616   0.000021  SyntaxCheckers_zsh_zsh_GetLocList()
    1   0.004317   0.000226  SyntasticMake()
  157   0.002513             syntastic#util#getbufvar()
    1   0.000804   0.000091  <SNR>30_BufWritePostHook()
    5   0.000782             syntastic#util#fname2buf()
    1   0.000693   0.000198  76()
    1   0.000628   0.000150  <SNR>30_QuitPreHook()
    1   0.000624   0.000073  81()
    1   0.000451   0.000235  91()
    1   0.000316   0.000083  <SNR>30_BufReadPostHook()
    3   0.000301   0.000143  <SNR>30__skip_file()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  155              0.024862  48()
  157   0.011001   0.008393  39()
  155   0.038894   0.003099  SyntasticStatuslineFlag()
  157              0.002513  syntastic#util#getbufvar()
    5              0.000782  syntastic#util#fname2buf()
    2   0.008005   0.000398  syntastic#util#system()
    1   0.000451   0.000235  91()
    1   0.004317   0.000226  SyntasticMake()
    2   0.007671   0.000206  <SNR>30_UpdateErrors()
    1   0.000693   0.000198  76()
    1   0.006196   0.000191  <SNR>30_CacheErrors()
   34   0.000294   0.000185  syntastic#log#debug()
    5              0.000155  38()
    1   0.000628   0.000150  <SNR>30_QuitPreHook()
    3   0.000301   0.000143  <SNR>30__skip_file()
   41              0.000141  <SNR>120__isDebugEnabled_smart()
    1              0.000132  syntastic#util#setWids()
   25   0.000236   0.000126  syntastic#util#var()
    1   0.000170   0.000119  77()
   25              0.000110  syntastic#util#rawVar()

